;; This buffer is for text that is not saved, and for Lisp evaluation.
;; To create a file, visit it with C-x C-f and enter text in its buffer.


* Установка Arch Linux рядом с Windows 10. UEFI. systemd-boot (без GRUB)
Установка Arch Linux рядом с Windows 10. UEFI. systemd-boot (без GRUB)

**Установка Arch Linux рядом с Windows 10. UEFI.systemd-boot (без GRUB)**  
  

**Требуется**

Установка  базовой системы Arch Linux 64-bit рядом с Windows 10. UEFI.   
Использование менеджера загрузки systemd-boot. 

**Запускаемся с USB**** в режиме EFI**

**Проверяем**** режим****EFI**

efivar -l

Должны вывестись список строк.

[![](../_resources/e4fe32604acb494fb9da1791e6d5f9ad.png)](https://2.bp.blogspot.com/-hPr2Vqxvop4/WHvjpo-D4lI/AAAAAAAA3zY/0hS-l_ilMc4pe4QvWPwX20MoYZJUn69swCLcB/s1600/efivarpng.png)

**Подключаем интернет**

wifi-menu

Выбираем сеть, вводим пароль.

**Проверяем наличие интернет**

ping ya.ru

Должны начать выводиться списки загружаемых пакетов

Прерываем и выходим из ping командой ctrl+c  
  

  

[<img width="640" height="347" src="../_resources/1cd7a15fdbd1418a81f8e6f07545a003.png"/>](https://1.bp.blogspot.com/-7ZsPUtqpbBg/WHvP73roSKI/AAAAAAAA3yg/zsw8gFjAokoeUcI3YSrPRoI2yNUkSa9dACLcB/s1600/ping.png)

**Синхронизация системных часов**  
timedatectl set-ntp true  
  
**Посмотрим наши старые загрузочные записи (если есть)**

efibootmgr

[<img width="400" height="202" src="../_resources/69f15df9cda64ba497f2934d820b5f87.png"/>](https://2.bp.blogspot.com/-F_QcCzYAm_Q/WId3RN3lxqI/AAAAAAAA4W8/xIV_Lf6SiFAro9LyZfDor9ahNMULG6XkwCLcB/s1600/efivar.png)

  
1\. Видим, что загрузились через USB UEFI  
2\. Загрузчик Windows  
3-5. Записи прочих загрузчиков. Если в свое время устанавливались другие дистрибутивы в раздел EFI, то таких записей может быть несколько. В любом случае визуально все можно понять.  
  
Удаляем не нужные записи командой efibootmgr -b _**x**_ -B,  где x - номер записи в списке по последней цифре. В моем случае это записи 3,4,5**.**  
efibootmgr -b 0 -B

efibootmgr -b 2 -B  
efibootmgr -b 5 -B  
  

[<img width="430" height="640" src="../_resources/73ad218705c04df1b53300960cfe952f.png"/>](https://1.bp.blogspot.com/-snu7cGjU9Kw/WIeCppjOK4I/AAAAAAAA4X0/u8eNXxmnZBUfgpmLte8Wso_s8onQ0UxtwCLcB/s1600/efibootB.png)

  
  
**Просмотрим разделы Windows**  
  
Видим, что раздел EFI находится на /dev/sda2. Сюда будем подключать наш загрузчик.  
/dev/sda3 и /dev/sda4 - это, соответственно, диски C и D на Windows.  
  

[<img width="640" height="316" src="../_resources/e547594c725f4c22b548b6537c855970.png"/>](https://1.bp.blogspot.com/-qiS7xSLp-HY/WId6qN9PnTI/AAAAAAAA4XI/cmI2f8Pf3lkAHrcg3lZjNsEseviwGvLWQCLcB/s1600/ldisk.png)

**Разметка диска**

cfdisk  
  
На свободном месте добавляем разделы  
  

_Для root_

new 20G type system linux подтверждаем write

_Для swap_

new 4.8G type linux swap подтверждаем write  
  
_**Раздел /dev/sda2 с EFI не трогаем**, раздел под  /home я не создавал, так как пользоваться им практически не придется. Вся инфа лежит на windows разделе. Размер для root и swap, каждый выбирает на свое усмотрение._

Выходим из cfdisk через quit

[<img width="640" height="118" src="../_resources/d77a2c2f47f2425f8376295e025e1be1.png"/>](https://3.bp.blogspot.com/-s_v5vYBztXk/WId-Y9H6GFI/AAAAAAAA4XU/_e2nkQGRD6ky_P5TM1z8vKwa_7BUmjZBQCLcB/s1600/cfdisk.png)

**Получaем разделы**

_root - sda5_

_boot - sda2_

_swap - sda6_

**Форматирование и подключение**

_#root_

mkfs.ext4 /dev/sda5 -L "ARCH"

mount /dev/sda5 /mnt

_#boot_

mkdir -p /mnt/boot

mount /dev/sda2 /mnt/boot

_#swap_

mkswap /dev/sda6 

swapon /dev/sda6  
  

**Просматриваем и проверяем ****разделы**** и подключение**

cfdisk

[![](../_resources/d1391c26618f4cb1a87d83684aa53b91.png)](https://1.bp.blogspot.com/-yWbVu7JCnlw/WId_T0VhXEI/AAAAAAAA4XY/5V8SOgL5zcQo8Qkt9LRFSe8c349UTD7_gCLcB/s1600/cfdisk2.png)

**Выходим из cfdisk**

  

**Обновляем пакеты**

pacman -Syy

При обновлении пакетов видна скорость скачивания с сервера. Если устраивает,то следующий пункт можно пропустить. 

[![](../_resources/4d20032903f34008a08aaf20343d822d.png)](https://4.bp.blogspot.com/-fbZTJ0sbuM4/WHvQWiorvbI/AAAAAAAA3yo/rdw9nCbtDGg6dbz0IKMWaRFLz82fA6LmgCLcB/s1600/speed%2Bpacman.png)

**Настройка сервера загрузки, как пример, для российского сервера.**

nano /etc/pacman.d/mirrorlist

Вверху прописываем 

Записываем изменения командойctrl+o 

Подтверждаем enter Выходим из редактора ctrl+x

[<img width="640" height="319" src="../_resources/045234fe2bd142418089b87dc713d74a.png"/>](https://4.bp.blogspot.com/-KY7gIQQmBGA/WHvQkZopHLI/AAAAAAAA3ys/rQqghlsyw88I21jYkpcTp5qDzUBoIIUuACLcB/s1600/arch%2Bmirrorgenerator.png)

[![](../_resources/97d6a2ef7f664fd48b7aeb70b5086dd3.png)](https://2.bp.blogspot.com/-hGOIW0Z4jQo/WHvQw-KyCgI/AAAAAAAA3y0/r9s3xqIi6DsTTigMXIyoOXUde348eklBwCLcB/s1600/arch%2Bmirrorgenerator%2B2.png)

**Устанавливаем базовую систему и пакет для будущего использования AUR.**

pacstrap /mnt base base-devel

**Генерируем fstab**

genfstab -L -p -P /mnt>> /mnt/etc/fstab  
  

  

**Просмотрим созданный fstab**

nano /mnt/etc/fstab

[<img width="640" height="224" src="../_resources/20400e0a6532414bb15252585dc17157.png"/>](https://4.bp.blogspot.com/-JBUsbLbwlYs/WId__x6WIfI/AAAAAAAA4Xg/iOrKSo4Z670nDnKv9GEq-oeLLBwaCBhDQCLcB/s1600/fstab.png)

**Переходим в систему**

arch-chroot /mnt 

**Настроим локаль, время****, имя компьютера**  

loadkeys ru

setfont cyr-sun16

nano /etc/locale.gen

Здесь раскомментирум строки

en_US.UTF-8 UTF-8

ru_RU.UTF-8 UTF-8

Записываем изменения командой ctrl+o 

Подтверждаем enter

Выходим из редактора ctrl+x

locale-gen

nano /etc/locale.conf

Прописываем строку

LANG=ru_RU.UTF-8

Записываем изменения командой ctrl+o

Подтверждаем enter

Выходим из редактора ctrl+x

export LANG=ru_RU.UTF-8

nano /etc/vconsole.conf

Прописываем строки

KEYMAP=ru

FONT=cyr-sun16

Записываем изменения командой ctrl+o

Подтверждаем enter

Выходим из редактора ctrl+x

Настраиваем зону и системное время, как пример, для Россия Москва

ln -sf /usr/share/zoneinfo/Europe/Moscow /etc/localtime

hwclock --systohc

Настраиваем имя компьютера

nano /etc/hostname

Прописываем

userhost - _имя вашего компьютера_

Записываем изменения командой ctrl+o

Подтверждаем enter

Выходим из редактора ctrl+x

nano /etc/hosts 

Прописываем строчку

127.0.1.1 _userhost_.localdomain _userhost_

Записываем изменения командой ctrl+o

Подтверждаем enter

Выходим из редактора ctrl+x

[![](../_resources/687d113ea590416fad47c10f7e920916.png)](https://4.bp.blogspot.com/-2tZb5RRDGTw/WHvQ-ziVfCI/AAAAAAAA3y4/OCsl0azb6iYIvq-6-o_Bcm1H6VL6XwbngCLcB/s1600/hosts.png)

**Устанавливаем пароль для root**

passwd

**Здесь же добавляю ****нового ****пользователя**

useradd -G wheel -s /bin/bash -m _username_  
_где username - ваше имя пользователя_

**Открываем права для нового пользователя**

nano /etc/sudoers

Раскомментируем строку %wheel ALL=(ALL) ALL

Записываем изменения командой ctrl+o

Подтверждаем enter

Выходим из редактора ctrl+x

[<img width="640" height="302" src="../_resources/460af6c81da247289defc9f1095e4392.png"/>](https://4.bp.blogspot.com/-kLGn6RBD_7Q/WHvRIg_J8NI/AAAAAAAA3y8/aGHd8VzKTIItYCT5ZgKkySGK2XzzmdTcgCLcB/s1600/sudoers.png)

**Устанавливаем пароль для нового пользователя**

passwd _username_

**Устанавливаем дополнительные пакеты (и пакеты, которые вы считаете нужными)**

pacman -S  efibootmgr iw wpa_supplicant dialog  
  
**Запускаем менеджер загрузки**  
  
bootctl install

Будут созданы  необходимые директории и точка входа загрузчика

[<img width="640" height="122" src="../_resources/553055d1f73746b89b1f0ba850a1533f.png"/>](https://2.bp.blogspot.com/-lNW52Qcf_Y0/WIeAxAgSbUI/AAAAAAAA4Xk/jbLFFvsEsi0gf9XJuBI1b2znGENqtkbzQCLcB/s1600/bootctl.png)

  
**Настраиваем менеджер загрузки**  
nano /boot/loader/loader.conf  
  
Закомментируем все строки, добавим свои  
  
default arch                     
timeout 5  
editor 1  
  
_Инфа из WIKI_  
  

[![](../_resources/ab1f581eb45f4047a63a27ab9d41eef6.png)](https://2.bp.blogspot.com/-f_RS72Pw9BI/WIHpzUcjJAI/AAAAAAAA4MA/4_3IpjnM-dsU63J51aDsYD0gDcgQzz07ACLcB/s1600/loader%2Bwiki.png)

Получаем

[![](../_resources/10a2d90176194260aee30c63e7cc313e.png)](https://2.bp.blogspot.com/-DkXYOUT_upc/WIHqKML-IQI/AAAAAAAA4ME/-mceAuSMknQHQMYhqWltKtXRuc0jdlbEgCLcB/s1600/loader.png)

  
**Создаем файлы конфигурации**  
_Для пользователей процессоров Intel нужно установить дополнительный пакет _  
_pacman -S intel-ucode_  
nano /boot/loader/entries/arch.conf  
  
title Arch Linux  
linux /vmlinuz-linux  
\# initrd  /intel-ucode.img       # раскомментировать для пользователей Intel  
initrd /initramfs-linux.img  
options root=/dev/**sda5** rw  
  
Здесь **sda5** \- это наш примонтированный root раздел  
  
**Просмотрим последовательность при запуске системы**  
  

efibootmgr  
**Установим выбранную последовательность загрузки **

  
efibootmgr -o 0,3,4,1  _\# в моем случае Arch будет первым_  

[<img width="400" height="127" src="../_resources/2984fa026af54c1ebf0f1664c9f67df0.png"/>](https://2.bp.blogspot.com/-c5UvXxoQFNk/WIeHRdrTgUI/AAAAAAAA4YA/1BPsoDzBUqMzcC_zphmreEPWz_9A3-X5QCLcB/s1600/efivarOK.png)

  
**Выходим**

exit

**Отмонтируем диски**

umount -R /mnt

**Перегружае****м****ся**

reboot  
  
  

[<img width="640" height="104" src="../_resources/1063ce8141eb42ad96c062ed3c3351d9.png"/>](https://3.bp.blogspot.com/-rGEGm4mZ118/WIeH796pPLI/AAAAAAAA4YI/HnzAjCeJSh4Q_i3q1UD1vZCUkWvU3pouACLcB/s1600/welcome.png)

**Базовая система установлена. Остальное  устанавливаем на свой вкус и цвет.**

**...далее**

**Arch «будет тем, что вы из него сделаете»**

**Удачи!**

_Ссылки по теме_

_[Arch Linux Cinnamon. Установка. Настройка](https://sollus-soft.blogspot.com/2018/10/arch-linux-cinnamon-ssd-uefi-systemd.html#more)_  
 _[Моя установка Arch Linux 64-бит с рабочим окружением XFCE. UEFI. GRUB](https://goo.gl/HbHOZI)_  
_Возможно будет интересно_  
_[Установка OverGrive - клиента Google Drive для Linux](https://goo.gl/Odw5Nt)_
* Перенос папки home на другой диск
Перенос папки home на другой диск.

Перенос папки /home на другой диск.
============================================
Я делал так. Опишу для случая, когда /home находится на корневом разделе.

 1.   Монтируем раздел куда-нибудь, в который нужно перенести /home:
 2.   Копируем содержимое /home в смонтированный раздел:

```
cp -a /home/* /путь_к_разделу
```

Опция -a означает, что делается резервная копия и все права на файлы нужно сохранить как у оригинала.
3.   Прописываем в /etc/fstab новый раздел в качестве /home:

```
UUID=Идентификатор_монтируемого_раздела	/home	файловая_система_раздела 	nosuid,relatime	1	2
```

Индентификатор раздела и файловую систему можно узнать командой:

`blkid`

Возможно не лишним в опциях будет указать noexec. Это будет запрет на запуск файлов, находящихся в /home. Вы не сможете запускать ни сценарии, ни бинарники в этом разделе. Нужно для безопасности. Решать вам.
4.  Монтируем новый раздел в /home

```
mount /dev/Ваш_раздел
```

Так как он прописан в fstab, то точку монтирования указывать не надо.
5. Убеждаемся, что всё в порядке. Стоит перезагрузиться.
6. Отмонтируем:

```
umount /dev/Ваш_раздел
```

7. Удаляем содержимое /home


```
rm -R /home/*
```

 Монтируем раздел в /home:


```
mount /dev/Ваш_раздел
```


С 7 шагом поосторожнее ;-) А так, даже в графике получается всё сделать. Но будет лучше если вы эту инструкцию себе распечатаете, так как при переключении между эмулятором терминала и браузером при пустом /home сеанс и упасть может.
Все действия делаются от root
* Настройка UEFI-загрузчика. Самое краткое руководство в мире
Настройка UEFI-загрузчика. Самое краткое руководство в мире

Как устроена загрузка современных ОС? Как при установке системы настроить загрузку посредством UEFI, не утонув в руководствах и ничего не сломав?

Я обещал "самое краткое руководство". Вот оно:

  

1.  Создаём на диске таблицу разделов GPT
2.  Создаём FAT32-раздел на пару сотен мегабайт
3.  Скачиваем из интернета любой UEFI-загрузчик  
    (нам нужен сам загрузчик, это один бинарный файл!)
4.  Переименовываем и кладем этот файл на созданный раздел по адресу /EFI/Boot/bootx64.efi
5.  Создаём текстовый конфиг, кладем его там, где загрузчик ожидает его увидеть  
    (настройка и местоположение конфига зависят от конкретной реализации загрузчика, эта информация доступна в интернете)
6.  После перезагрузки видим меню загрузчика  
    _(Если на диске установлена Windows 8 или 10 — с большой вероятностью это руководство сокращается до пунктов 3 — 5.)_

**TL;DR не надо прописывать путь к загрузчику в новых загрузочных записях UEFI — надо файл загрузчика расположить по стандартному "пути по-умолчанию", где UEFI его найдет, и вместо загрузочного меню UEFI пользоваться меню загрузчика, которое гораздо проще и безопаснее настраивается**

## Как делать не надо

Есть, на самом-то деле, несколько способов настроить UEFI-загрузку. Я начну с описания других вариантов — чтобы было понятно, как (и почему) [делать не надо](https://habrahabr.ru/post/259283/). Если вы пришли за руководством — мотайте в самый низ.

  

#### Не надо лезть в NVRAM и трогать efivars

Наиболее "популярная" процедура установки загрузчика в систему такова: установщик ОС создаёт специальный раздел, на нём — структуру каталогов и размещает файлы загрузчика. После этого он с помощью особой утилиты (efibootmgr в linux, bcdedit в windows) взаимодействует с прошивкой UEFI-чипа, добавляя в неё загрузочную запись. В этой записи указывается путь к файлу загрузчика (начиная от корня файловой системы) и при необходимости — параметры. После этого в загрузочном меню компьютера появляется опция загрузки ОС. Для linux существует возможность вообще обойтись без загрузчика. В загрузочной записи указывается путь сразу к ядру вместе со всеми параметрами. Ядро должно быть скомпилировано с опцией EFISTUB (что давно является стандартом для большинства дистрибутивов), в этом случае оно содержит в себе заголовок "исполняемого файла EFI", позволяющий прошивке его запускать без внешнего загрузчика.

При старте системы, когда пользователь выбирает нужную ему загрузочную запись, прошивка UEFI сперва ищет на прописанном в этой записи диске особый EFI-раздел, обращается к файловой системе на этом разделе (обязательно FAT или FAT32), и запускает загрузчик. Загрузчик считывает из файла настроек свой конфиг, и либо грузит ОС, либо предоставляет загрузочное меню. Ничего не замечаете? Да, у нас два загрузочных меню — одно на уровне прошивки чипа UEFI, другое — на уровне загрузчика. В реальности о существовании второго пользователи могут даже не догадываться — если в меню всего один пункт, загрузчик Windows начинает его грузить без лишних вопросов. Увидеть экран с этим меню можно, если поставить вторую копию Windows или просто криво её переустановить.

Обычно для управления загрузочными записями руководства в интернете предлагают взаимодействовать с прошивкой UEFI. Есть аж пять основных вариантов, как это можно сделать: efibootmgr под linux, bcdedit в windows, какая-то софтина на "Маках", команда bcfg утилиты uefi shell (запускается из-под UEFI, "на голом железе" и без ОС, поскольку скомпилирована в том самом особом формате) и для особо качественных прошивок — графическими средствами UEFI (говоря популярным языком, "в настройках BIOS").

За всеми вышенаписанными "многобуков" вы могли легко упустить такую мысль: пользователь, чтобы изменить настройки программной части (например, добавить параметр запуска ОС), вынужден перезаписывать flash-память микросхемы на плате. Есть ли тут подводные камни? О да! Windows иногда [способна сделать из ноутбука кирпич](http://www.pcworld.com/article/2027819/not-just-linux-windows-can-brick-samsung-laptops-too.html), linux [тоже](https://www.phoronix.com/scan.php?page=news_item&px=UEFI-rm-root-directory), причём [разными способами](https://medium.com/@varunmittal91/101-brick-lenovo-uefi-computer-in-three-easy-steps-ab48acb789d8#.swz24tro1). Качество прошивок часто оставляет желать лучшего — стандарты UEFI либо реализованы криво, либо не реализованы вообще. По логике, прошивка обязана переживать полное удаление всех переменных efivars без последствий, не хранить в них критичных для себя данных и самостоятельно восстанавливать значения по-умолчанию — просто потому что пользователь имеет к ним доступ, и вероятность их полного удаления далека от нуля. Я лично в процессе экспериментов неоднократно (к счастью, обратимо) "кирпичил" свой Lenovo — из загрузочного меню исчезали все пункты, включая опцию "зайти в настройки".

Работа с загрузочными записями UEFI — тоже не сахар. К примеру, утилита efibootmgr не имеет опции "редактировать существующую запись". Если ты хочешь немного изменить параметр ядра — ты удаляешь запись целиком и добавляешь её снова, уже измененную. При этом строка **содержит в себе двойные и одинарные кавычки, а также прямые и обратные слеши** в не особо очевидном порядке. Когда я наконец заставил эту магию работать — я сохранил её в виде bash-скриптов, которые до сих пор валяются у меня в корневой ФС:

  

    efibootmgr -c -L "Archlinux (debug)" -l '\EFI\archlinux\vmlinuz-linux' -u "root=/dev/mapper/vg1-lvroot rw initrd=\EFI\archlinux\initramfs-linux.img systemd.log_level=debug systemd.log_target=kmsg log_buf_len=1M enforcing=0"

  

#### Не надо использовать GRUB

Это чёртов мастодонт, 90% функциональности которого предназначено для дисков с MBR. Для настройки необходимо отредактировать ряд файлов, после чего выполнить команду генерации конфига. На выходе получается огромная малопонятная нормальному человеку простыня. В составе — гора исполняемых файлов. Ставится командой, которую просто так из головы не возьмешь — надо обязательно лезть в документацию

  

    grub-install --target=x86_64-efi --efi-directory=esp_mount --bootloader-id=grub

Для сравнения — самый простенький UEFI-bootloader, который есть в составе пакета systemd, ставится командой

  

    bootctl install --path=/boot

Эта команда делает ровно две вещи: копирует исполняемый файл загрузчика на EFI-раздел и добавляет свою загрузочную запись в прошивку. А конфиг для неё занимает ровно СЕМЬ строчек.

  

## "Самое краткое руководство" — чуть более подробно

**Загрузочное меню надо реализовывать на уровне загрузчика** — править текстовые конфиги гораздо проще и безопасней.

**Загрузочная запись нам не нужна — дело в том, что при выставлении в настройках BIOS загрузки с диска прошивка UEFI сначала ищет на нём EFI-раздел, а затем пытается исполнить файл по строго фиксированному адресу на этом разделе: /EFI/Boot/BOOTX64.EFI**

Что такое "EFI-раздел"? В теории, он должен иметь особый тип "EFI System" (ef00). На практике, **годится первый раздел на GPT-диске, отформатированный в FAT32 и имеющий достаточно места**, чтобы разместить загрузчик и вспомогательные файлы (если есть).

Пункт 3: **"Скачиваем из интернета любой UEFI-загрузчик"**. Что это значит? Загрузчик — это просто исполняемый файл определенного формата, к которому в комплекте идет конфиг. К примеру, если у вас есть под рукой установленный пакет с systemd — файл загрузчика можно найти по адресу /usr/lib/systemd/boot/efi/systemd-bootx64.efi, переименовать его в bootx64.efi и скопировать в /EFI/Boot/ на EFI-разделе. Нет под рукой systemd? Скачайте архив с сайта Archlinux. Или с репозитария Ubuntu. Или Debian. Есть под рукой система с Windows? Возьмите виндовый загрузчик оттуда, тоже сгодится )) Если сумеете настроить, я честно говоря не пробовал.

Пункт 4: **"Настроить конфиг"**. Как и обычная программа, когда загрузчик запускается — он ожидает найти по определенным путям файлы конфигурации. Обычно эту информацию легко найти в интернете. Для загрузчика systemd-boot нам необходимо в корне EFI-раздела создать каталог "loader", а в нём файл "loader.conf" с тремя строчками (привожу свои):

  

    default     archlinux
    timeout     10
    editor      1

_Параметр editor отвечает за возможность отредактировать пункт загрузочного меню перед запуском._

Рядом с loader.conf необходимо создать каталог entries — один файл в нём будет отвечать за одну загрузочную запись в boot-меню. У меня там один файл arch.conf с таким содержанием:

  

    title          Arch Linux
    linux          /efi/archlinux/vmlinuz-linux
    initrd         /efi/archlinux/initramfs-linux.img
    options        root=/dev/mapper/vg1-lvroot rw initrd=\EFI\archlinux\intel-ucode.img

_Я не упомянул, но довольно очевидно — ядро и initramfs должны лежать в одной файловой системе с загрузчиком, то есть на EFI-разделе. Пути к ним в конфигах отсчитываются от корня этой ФС._

  

## Другие загрузчики

systemd-boot очень простой и предоставляет спартанского вида чёрно-белое меню. Есть варианты красивей, если душа просит красоты.

rEFind — [очень красивый](https://yandex.ru/images/search?text=refind) загрузчик. [Скачать](https://sourceforge.net/projects/refind/) можно тут в виде deb-пакета. Использую на своём ноуте. Умеет создавать загрузочное меню автоматически, без конфига — просто сканируя файлы.

[Clover](https://sourceforge.net/projects/cloverefiboot/?source=typ_redirect). Позволяет выставлять нативное разрешение экрана, имеет поддержку мыши на экране загрузки, разные темы оформления. Дефолтная тема ужасна, конфиг в виде xml нечитаем, настроить не смог.

  

## Различные неочевидные последствия

Вы можете легко попробовать эту схему в работе. Берёте USB-флешку, форматируете в таблицу разделов GPT, создаете FAT-раздел и копируете туда загрузчик. Комп сможет с неё стартовать.

Если просто скопировать на такую флешку boot-раздел установленного linux — система будет спокойно загружаться с флешки, не видя разницы.
* Настройка UEFI Dual Boot системы, приправленной rEFInd
Настройка UEFI Dual Boot системы, приправленной rEFInd

![](../_resources/bc1dfe65f6d2478891a853db792883d3.png)  
_КДПВ. [Бут-менеджер rEFInd](http://www.rodsbooks.com/refind/) с темой оформления [Regular](https://github.com/munlik/refind-theme-regular/)._

На сегодняшний день практически все уже слышали про технологию UEFI. Говорить о том, что это такое и зачем оно нужно, я не собираюсь. Сегодня я бы хотел описать простейший сценарий установки Dual Boot системы с полной поддержкой UEFI, а также рассмотреть отдельно установку и настройку бут-менеджера rEFInd. Возможно вы уже видели подобные мануалы и гайды, но я постараюсь донести весьма доходчиво суть того, что мы будем делать и зачем. В других мануалах вы лишь смотрите за «магией» картежника и пытаетесь её повторить, делая, зачастую, элементарные ошибки. Кому эта тема интересна — прошу под кат.

В целом UEFI призвана наоборот упросить процесс загрузки, а не усложнить его. К примеру, посредством этой технологии компьютер можно загружать ОС и вовсе без прослойки в лице GRUB / LILO / etc, загрузчиком может выступать сама UEFI. Однако этот метод имеет свои недостатки, например, вам придется повозиться после обновления ядра, можно, разумеется, написать скрипт, но в целом этим и занимается `grub2-efi`

Итак, давайте сформируем примерный список наших действий, некоторым хватит прочесть его и уже взяться за дело. Собственно тут будет всего **четыре** пункта. **Пятый и шестой пункт опционален.**

1.  Запись образа Windows 10 (8/8.1) на диск/флешку.
2.  Установка Windows 10 на часть диска.
3.  Запись образа Linux-дистрибутива с поддержкой EFI (большинство) на диск/флешку.
4.  Установка Linux-дистрибутива на оставшуюся часть диска.
5.  Установка и конфигурация rEFInd.
6.  Удаление GRUB и полный переход на rEFInd.

На первый взгляд всё очень просто, всего 4 базовых пункта, но тут есть огромное количество нюансов.

Ошибки делают на всех этапах: входят в режим Legacy-bios, указывают не тот загрузочный раздел, просто не понимают, что делают и т.д. В конечном итоге всё это приводит к массе боли и страданиям на форумах, в чатах, и т.д. На деле же всё нереально просто, нужно просто понимать, что ты делаешь на каждом этапе и проверять себя.

## Сначала немного теории

UEFI видит только один специальный ESP-раздел, обычно он имеет размер 100-200 мегабайт и форматирован в FAT32 (бывает в FAT16), в нем содержаться папки с названиями а-ля Boot, Microsoft, Fedora, Ubuntu и т.д. Если вы перепробовали достаточное количество ОС и никогда не форматировали этот раздел, то там могло набраться приличное количество папок. К примеру, у меня было 2 живых оси и лежало около 6 папок.

**P.S.** [CodeRush](https://habr.com/users/coderush/) подсказал, что поддерживаются все FS, если на них есть [соответствующие драйверы](http://efi.akeo.ie/downloads/efifs-0.9/x64/):

> Это неверно. UEFI видит все разделы, для ФС которых в конкретной реализации прошивки имеются драйверы. ESP же отличается от остальных разделов только тем, что а) для FAT драйвер иметь обязательно и б) на разделе ESP осуществляется поиск загрузчиков и автоматическое создание соответсвующих переменных BootXXXX, если загрузчики нашлись.

В самих папках лежат исполняемые файлы .efi которые и выступают в роли загрузчиков ОС. В папке debian вы наверняка обнаружите файл `grubx64.efi`, а в папке Microsoft – `bootmgr.efi`.

Большинство Linux-дистрибутивов монтируют ESP-раздел к `/boot/efi`, то есть загрузчик Debian будет лежать примерно на таком пути: `/boot/efi/EFI/debian/grubx64.efi`

C директорией разобрались, а что дальше?

А дальше нужно понимать, что существует ещё порядок загрузки, которым можно руководить с помощью утилиты `efibootmgr`, если у вас её нет, то можете скачать через свой пакетный менеджер, во всех стандартных репозиториях она присутствует. Для начала можете просто ввести эту команду и увидеть список порядка загрузки, а также все UEFI-записи. Если хотите разобраться с утилитой, то курите ман и читайте интернеты, в целом она весьма простая. Злой Windows как раз-таки тут и затирает наш GRUB и ставит Windows Boot Manager первым приоритетом, поэтому его приходится восстанавливать. Скажу лишь как редактировать записи:  
`efibootmgr -b <номер записи> -<модификатор редактирования> <параметр модификатора>`  
К примеру, `efibootmgr -b 0 -B` означает удалить запись 0.

**P.S.** [CodeRush](https://habr.com/users/coderush/) и другие комментаторы заметили, что efibootmgr является весьма опасной утилитой и отмечают, что гораздо безопасней пользовать EFI Shell.

По факту GRUB можно вообще не трогать, потому что он наверняка так и лежит в папке `EFI/<название дистрибутива>`, нужно лишь восстановить запись и выставить первый приоритет, но зачем что-то копать если можно chroot’нуться и ввести `grub-install`? В большинстве случаев он сделает всё сам.

Кстати, стоит не забывать, что базовым функционалом `efibootmgr` обладает и сам, собственно, UEFI, он умеет читать эти записи и выстраивать приоритеты. Но сам просматривать ESP-разделы и добавлять новые записи он не умеет, эти обязанности возложены на EFI Shell и операционные системы.

**P.S.** [CodeRush](https://habr.com/users/coderush/)

> Еще как умеет, и это умение требуется спецификацией начиная с UEFI 2.2 (SecureBoot появился в UEFI 2.3.1C).

**И на последок:** Все ваши действия в `efibootmgr` записываются в NVRAM! В большинстве случае UEFI умеет восстанавливать битый NVRAM каждый раз проверяя его и перезаписывая, в случая неполадок. Однако некоторые недобросовестные производители выпускают сырые прошивки и можно получить самый настоящий кирпич. К примеру ноутбуки с UEFI на базе Phoenix SCT окирпичиваются! Так что перед тем как продолжить читать, удостоверьтесь, что ваша модель материнской карты или ноутбука, устойчива к таким экспериментам.

**P.S.** Уже после написания большей части статьи я вспомнил про Secure Boot. Обычно UEFI тянет его за собой, но в большинстве случаев его можно весьма просто отключить в настройках UEFI. Многие Linux-дистрибутивы поддерживают его, но я всё же рекомендую его отключить, так как он может потянуть за собой массу проблем.

Базовый экскурс в теорию закончен.

## Теперь можно перейти к практике

**Дисклеймер**: Сразу оговорю, что я предпочитаю стерильные условия и сам делаю полную переустановку с помощью проверенных лично мной утилит. Если вы будете использовать другие утилиты, то, пожалуйста, не пишите почему у вас что-то не получается на том или ином этапе. Мой вариант проверен сотнями переустановок друзьям и коллегам.

### Первым делом нам нужно записать Windows

Потому что если поставить Windows второй, то она затрет загрузчик. Восстановить? Без проблем. Но зачем возня, если можно сразу сделать всё по уму? Впрочем я всё равно обговорю нюансы восстановления чуть позже в конце статьи.

В отличии от Linux, Windows записать гораздо проще, на мой взгляд. Первый способ до возможно многим знаком, нужно просто зайти в cmd.exe от имени администратора и ввести эти команды. Не сложно заметить, то тут нет абсолютно никакой магии. Мы просто форматируем флешку в FAT32:

`diskpart  
list disk  
select disk <номер флешки>  
clean  
create partition primary  
select partition 1  
active  
format fs fat32 quick  
assign  
exit`

После этого нужно просто открыть ISO-файл архиватором и перекинуть содержимое на чистую флешку. Всё, UEFI-флешка готова. На Linux можно сделать всё аналогичным образом, просто форматируем в FAT32 и копируем содержимое.

Полученную флешка должна отлично загружаться любым ПК с поддержкой UEFI.

> Кстати, обратимся к теории: наш образ с Windows 10 содержит папочку efi, в ней как раз лежит всё добро для начала загрузки, которое должен увидеть наш UEFI. Поэтому простого форматирования и копирования в большинстве случаев хватает для большинства ПК.

Однако я предпочитаю второй способ с использованием [утилиты Rufus](http://rufus.akeo.ie/). Он меня никогда не подводил. Однако это Windows-only способ. На Linux-системах использование ddresque для создания загрузочной флешки Windows НЕ РАБОТАЕТ. Так что пробуйте другие утилиты, если первый способ с простым форматирование не помог.

Всё что вам будет нужно: выбрать вашу флешку, выставить параметр _«Схема раздела и тип системного интерфейса»_ на **_«GPT для компьютеров с UEFI»_**, и нажать старт. Остальные параметры трогать не нужно. Лучше использовать флешки помельче (на 8-16 гигабайт).

Наверняка один из способов должен был прокатить, лично я ни разу с проблемами на этом этапе не встречался, главное чтобы компьютер поддерживал UEFI.

### Поэтому перейдем к этапу установки

После загрузки в UEFI-режиме делаем всё по стандартной схеме, но на этапе выбора типа установки выбираем «экспертную», то есть мы разметим раздел сами. Размечать рекомендую аккуратно, особенно если дисков много. Наконец, выбрав диск, удалите все существующие разделы. Создайте один раздел с нужным вам размером, к примеру, 150 гигабайт. (Если вы предпочитаете создавать два и более разделов для ОС и файлов — без проблем, создавайте). Выберете этот раздел кликом мышки и нажмите _«Далее»_. И если вы всё сделали верно, то Windows попросит вас создать дополнительные. Обязательно отвечайте _«Да»_. Система создаст три раздела. Два своих для системных нужд и один тот самый нужный нам EFI-раздел. У меня он по нумерации всегда второй, всего получится 4 раздела, включая пользовательский NTFS. Если установщик не предложил создать разделы или создал всего один, то значит вы загрузились в Legacy-режиме и нужно перезаписывать флешку, что-то пошло не так. К сожалению редактор разделов Windows-установщика крайне слаб по возможностям, поэтому пробовать размечать разделы под будущий Linux тут смысла нет, оставляем это место попросту свободным. Дальше устанавливаем всё в штатном режиме.

Кстати, один из признаков правильной установки Windows в UEFI-режиме, появление логотипа производителя материнской карты / ноутбука / планшета при загрузке. Во многих UEFI (к примеру от ASUS и ASRock) есть отдельная настройка для этого. Так что если логотипа нет, но всё остальное прошло как по маслу, то ничего страшного в этом нет.

> Тонко настраивать Windows на данный момент не рекомендую, так как если что-то пойдет не так, то возможно придется переустановить.

### Записываем Linux?

Ага. После входа в Windows рекомендую сразу скачать образ выбранного вами дистрибутива и записать его аналогичным образом **через Rufus**. Правда в случае с Linux-дистрибутивами Rufus может спросить массу вопросов, к примеру он может попросить подгрузить загрузчик syslinux с интернета или выбрать режим записи образа: ISO или DD. На все вопросы отвечаем _«Да.»_, то есть да, скачиваем последнюю версию syslinux и записываем в режиме ISO. Проверено на Ubuntu (и её вариациях Server, Mate, GNOME), Fedora, RHEL7, Debian и других.

### До Dual Boot буквально один шаг

В отличии от Windows большинство дистрибутивов имеют отличную индикацию UEFI-режима. К примеру Debian в своем установщике черным по белому пишет, что система запущенна в UEFI-mode. Другие дистрибутивы проявляют это странным grub-загрузчиком, который выглядит «как-то не так».

Думаю если вы собрались ставить Linux, то вы наверняка сами знаете как ставить ваш любимый дистрибутив, поэтому я не буду заострять внимание на подробностях установки отдельно взятого дистрибутива. Потому что этот этап до боли прост. Если вы уже действительно прогрузились в UEFI-режиме и установили Windows как надо, то Dual Boot уже практически в кармане.

**Итак всё что вам потребуется сделать при установке Linux**:  
Выбрать раздел `/dev/sda2` (в вашем случае это может быть другой раздел) и указать точку монтирования — `/boot/efi`. Всё. Нет, правда, всё. Разумеется не забудьте разметить _ext4 / Btrfs / ReiserFS / XFS / JFS_ раздел, примонтировать его в корень /. Кому нужен swap (если нужен) создайте и его. Дальше установщик вашего дистрибутива сделает всё сам, установит в директорию `EFI/<название дистрибутива>` свой GRUB и найдет запись Windows (`EFI/microsoft`).

> Данная логика была проверена во всех вышеозначенных дистрибутивах. То есть повторюсь ещё раз: Главное показать вашему дистрибутиву где у вас этот заветный ESP-раздел и куда надо ему кидать загрузчик. Он его не форматирует, а просто добавляет GRUB. А вот уже сам GRUB вершит магию, изменяет приоритеты загрузки и т.д. Замечу, что некоторые дистрибутивы сами монтируют этот раздел куда надо, так как видят флаги ESP и BOOT. К примеру в установщике Debian нужно просто создать пользовательский раздел и всё.

## Наводим красоту, ставим rEFInd

К ~сожалению~ счастью я болею сильной формой перфекционизма. И простой GRUB2 меня не устраивал, больно он страшный и не красивый. Беглый гуглинг рассказал мне о BURG, «красивом» форке GRUB, но он был заброшен и на данный момент скорее мертв, чем жив. К счастью для UEFI-машин есть отличная альтернатива — rEFInd. rEFInd является форком, заброшенного ныне rEFIt, а также его логическим продолжением. Первый создавался в первую очередь для Mac'ов и работы рядом с Boot Camp, нынешний форк такой узкой специализации не имеет и подходит практически для любых конфигураций.

> Стоит сразу заметить, что rEFInd НЕ является загрузчиком. Это так называемый Boot Manager, он вызвает другие .efi-бинарники к исполнению, а также может направить UEFI на запуск ядра прямо с раздела `/boot`. Другими словами то есть систему загружает не он, а сам UEFI. Для Multi-Boot машин является отличным решением. Сам по себе rEFInd является .efi-приложением, собранным средствами UEFI Shell. Сам находится в директории `EFI/refind/refind_x64.efi`

Помимо того, что можно выбирать между уже установленными системами на ПК, приятным плюсом можно выделить автоматическое обнаружение загрузочных флешек и дисков. На КПДВ это можно увидеть. У меня имеется загрузочная флешка с Debian (не установщиком, а полноценной ОС) и можно увидеть удобную индикацию того, что это именно флешка, а не что-то другое. Если у вас имеется несколько ядер, то их список можно увидеть по нажатию клавиши F2. Помимо этого в файле `/boot/refind_linux.conf` можно задать несколько вариантов с разными параметрами ядра (например первый — стандартный для загрузки GUI, второй — безопасный режим без видеодрайвера и т.д, можно сделать дюжину вариантов, по умолчанию всего три). Также в папку `EFI/tools` можно накидать различных .efi-бинарников, к примеру UEFI Shell или memtest86+. rEFInd их автоматически подхватит и покажет в нижнем ряду как утилиты.

### Хотите также?

Процесс установки из под Linux необычайно прост. Все способы описаны на официальном сайте, устанавливать можно практически из любой ОС. Для начала [посетите эту страничку](http://www.rodsbooks.com/refind/getting.html) и скачайте .deb- или .rpm-пакет.

> Если у вас редкий дистрибутив вроде Slackware или Gentoo, то лично я вам помочь не смогу, но на сайте есть обычный .zip-архив и другие варианты установки, так что если уж вы работаете в подобных дистрибутивах, то наверняка поставить своими силами вы сможете без проблем.

Сделайте бэкап EFI-директории:  
`cp -r /boot/efi/EFI /boot/EFI.bkp`  
После загрузки пакета, выполните:  
`cd Downloads` или `cd Загрузки`  
И установите пакет:  
`sudo dpkg -i <имя пакета>.deb` или `sudo dnf install <имя пакета>.rpm`  
В моем случае `dpkg` не мог иногда подтянуть зависимости, если у вас возникнут такие же трудности, то установите gdebi (`sudo apt-get install gdebi`) и выполните `sudo gdebi <имя пакета>.deb`.

Если у вас RHEL или CentOS, то используйте `yum` вместо `dnf`.

В логах установки пакета можно отследить лог установки rEFInd, в котором возможно будут ошибки их надо сразу отследить. Однако по моему опыту ошибок не возникает, если всё сделать правильно. Проверить результат работы установщика rEFInd можно, воспользовавшись утилитой `efibootmgr`, там первым приоритетом должна должен быть именно rEFInd Boot Manager.

Установить rEFInd повторно, если пакет уже установлен, можно с помощью команды:  
`refind-install`  
Установку rEFInd первым приоритетом можно произвести в ручную, с помощью команды:  
`refind-mkdefault`

Перезагружаемся.

### Всё очень страшно и откуда у меня столько ОС?

Да, всё страшно, пока. На самом деле ОС у вас всего две. Просто rEFInd собрал все .efi-бинарники и ещё отобразил ОС с возможностью загрузки напрямую. Для исправления этого недоразумения мы удалим лишнее, напишем свой конфиг и поставим красивую тему на rEFInd.

Первым делом зайдите в Linux, выбрав один из рабочих пунктов загрузки. В меню должен быть пункт для загрузки БЕЗ использования grubx64.efi! В разделе `/boot` проще работать из под администратора (потому у команду `cd` не хватает привелегий, а `sudo` она не работает), так что `su` и вводим пароль root'а.

Этот пункт не зря опциональный, потому что если у вас недостаточно опыта, то можно очень просто что-то сломать и не заметить. Рекомендую подготовить флешку с рабочим LiveCD, чтобы проводить восстановление, в случае неожиданностей.

Наша первая задача — удалить лишние директивы загрузки, их запросто может быть штук 6, а системы всего две.

Заходим в директорию:  
`cd /boot/efi/EFI && ls`  
Вероятно тут будет пять папок:  
BOOT, microsoft, &lt;ваш дистрибутив&gt;, refind и tools.  
Если будет что-то лишнее — смело удаляйте.

**Способ 1 _(через очищение, опаснее)_**:  
Убедившись что вы загрузились через rEFInd (!) и НЕ использовали для этого GRUB можете смело удалить папку вашего дистрибутива. Перезагрузитесь и проверьте, можете ли вы загрузиться в ваш Linux. Если можете, то вероятно в меню загрузки осталось 4 директивы: Windows, Linux и два странных пункта, которые приводят (скорее всего) к загрузке Linux. Можно было догадаться, что это .efi-бинарники из папки `EFI/BOOT`. Папку можно удалить полностью. НО! Убедитесь, что у вас есть бэкап. Перазагружаемся. Всё отлично?

Удаляем GRUB:  
`sudo apt-get remove grub2 grub2-efi grub grub-efi`  
Или:  
`sudo dnf remove grub2`

Теперь можно ставить тему.

> Некоторые UEFI другие директории вовсе не видят. Поэтому небольшой work around для таких систем существует. Удаляем папку BOOT, переименовываем папку refind в папку BOOT, а также сам файл refind_x64.efi в bootx64.efi. Перезагружаемся.

**Способ 2 _(через конфиг rEFInd, безопаснее)_**:  
Этот способ гораздо безопаснее, потому что удалять и что либо трогать мы не будем, мы добьемся резальтата правильной настройкой конфига. Сам конфиг лежит тут: `/boot/efi/EFI/refind/refind.conf`  
Чтобы настроить свой набор директив загрузки нужно использовать два параметра `scanfor` и `menuentry`, после настройки должен получится примерно такой конфиг:

`# Сканируем записи созданные ручкуами, флешки и оптически приводы  
scanfor manual,external,optical  
# Пункт для загрузки Linux  
menuentry Linux {  
loader /EFI/ubuntu/grubx64.efi  
icon /EFI/refind/icons/os_linux.png  
}  
# Пункт для загрузки Windows 10  
menuentry "Windows 10" {  
loader \EFI\Microsoft\Boot\bootmgr.efi  
icon /EFI/refind/icons/os_win.png  
}  
`

Разумеется это только часть конфига, другие параметры можно взять из примера

**Мой конфиг на базе первого способа с комментариями**

`# Ожидание в секундах перед авто-выбором ОС  
timeout 20  
# Скринсервер через 300 секунд, если ничего не выбрали,  
# но нажали любую клавишу и отменили автовыбор  
screensaver 300  
# Разрешение бут-менеджера  
resolution 1280 1024  
# Использовать графику при загрузке Linux. Этот параметр позволит загружать ОС с красивой Plymouth  
# заставкой в разрешении указанном выше  
use_graphics_for linux  
scanfor internal,external,optical,netboot,biosexternal  
# Подключение темы  
include themes/refind-theme-regular/theme.conf  
`

Отдельно про Plymouth можно почитать [здесь](https://ru.wikipedia.org/wiki/Plymouth_%28%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%8D%D0%BA%D1%80%D0%B0%D0%BD_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B8%29).

**Включение красивой темы**

С этим всё просто, чуть выше последняя строчка конфига указывает на .conf-файл темы. Сами темы желательно класть в папку `/boot/efi/EFI/refind/themes`. По-умолчанию её нет, создайте через `mkdir`.  
Заходим в директорию themes и просто пишем `git clone https://github.com/munlik/refind-theme-regular.git`. В конфиге прописываем строку `include themes/refind-theme-regular/theme.conf`  
Другие темы можно посмотреть на [оф. сайте](http://www.rodsbooks.com/refind/themes.html).

Там же можно посмотреть подробные процессы установки, параметры для тонкой настройки конфига и многое другое.

Пожалуй на этом всё. Мы получили красивый бут-менеджер для выбора нужной ОС с полной поддержкой UEFI. Пункт с установкой rEFInd наиболее сложный, а поэтому опциональный, большинству хватит `grub2-efi`.

На последок небольшое видео от меня:

Наверняка закралось приличное количество ошибок в тексте, буду рад, если вы отпишите о них мне ЛС.
* Мой  Arch Linux рядом с Windows 10. UEFI. systemd-boot (без GRUB)
Мой  Arch Linux рядом с Windows 10. UEFI. systemd-boot (без GRUB)

### Установка Arch Linux рядом с Windows 10. UEFI. systemd-boot (без GRUB)


 >Предлагаю посмотреть на базовую установку Arch Linux 64 рядом с Windows UEFI с использованием менеджера загрузки systemd-boot




** Исходные данные

Комп Lenovo ideapad 320-15LSK model 80XH
 x64 с UEFI
Графика Device-1: Intel HD Graphics 520 driver: i915 v: kernel 
        Device-2: NVIDIA GM108M [GeForce 920MX] driver: N/A 
Оператива 8 Gb
Винт 1 Tb с системой разделов GPT
Установлена Windows 10 64-бит
Сеть WIFI
Образ скачан отсюда https://www.archlinux.org/download/ и записан на USB-носитель в Windows 10 при помощи приложения Rufus



** Требуется

Установка  базовой системы Arch Linux 64-bit рядом с Windows 10. UEFI. 
Использование менеджера загрузки systemd-boot. 

Запускаемся с USB в режиме EFI

Проверяем режим EFI

`efivar -l`

Должны вывестись список строк.
```
8be4df61-93ca-11d2-aa0d-00e098032b8c-dbxDefault
8be4df61-93ca-11d2-aa0d-00e098032b8c-dbDefault
8be4df61-93ca-11d2-aa0d-00e098032b8c-KEKDefault
8be4df61-93ca-11d2-aa0d-00e098032b8c-PKDefault
5bce4c83-6a97-444b-63b4-672c014742ff-IrsiInfo
146b234d-4052-4e07-b326-11220f8e1fe8-lBoot0002
8be4df61-93ca-11d2-aa0d-00e098032b8c-BootCurrent
74b00bd9-805a-4d61-b51f-43268123d113-Intel-pwrovr
193dfefa-a445-4302-99d8-ef3aad1a04c6-RstSataV
39473de5-df3b-49a1-9fa6-41b35b36fa39-DynamicBar
39473de5-df3b-49a1-9fa6-41b35b36fa39-FixedBar
8be4df61-93ca-11d2-aa0d-00e098032b8c-ErrOutDev
8be4df61-93ca-11d2-aa0d-00e098032b8c-ConInDev
59d1c24f-50f1-401a-b101-f33e0daed443-ActiveVgaDev
59d1c24f-50f1-401a-b101-f33e0daed443-ConOutCandidateDev
8be4df61-93ca-11d2-aa0d-00e098032b8c-ConOutDev
59d1c24f-50f1-401a-b101-f33e0daed443-ConInCandidateDev
b08f97ff-e6e8-4193-a997-5e9e9b0adb32-CpuSetupVolatileData
8be4df61-93ca-11d2-aa0d-00e098032b8c-PlatformLangCodes
8be4df61-93ca-11d2-aa0d-00e098032b8c-LangCodes
6acce65d-da35-4b39-b64b-5ed927a7dc7e-LvarSmiReadyFlag
8be4df61-93ca-11d2-aa0d-00e098032b8c-VendorKeys
8be4df61-93ca-11d2-aa0d-00e098032b8c-SignatureSupport
8be4df61-93ca-11d2-aa0d-00e098032b8c-OsIndicationsSupported
e20939be-32d4-41be-a150-897f85d49829-MemoryOverwriteRequestControl
8be4df61-93ca-11d2-aa0d-00e098032b8c-BootOrder
59d1c24f-50f1-401a-b101-f33e0daed443-PhysicalBootOrder
8be4df61-93ca-11d2-aa0d-00e098032b8c-Boot0002
8be4df61-93ca-11d2-aa0d-00e098032b8c-OsIndications
4a67b082-0a4c-41cf-b6c7-440b29bb8c4f-LoaderSystemToken
a04a27f4-df00-4d42-b552-39511302113d-Setup
8be4df61-93ca-11d2-aa0d-00e098032b8c-SecureBoot
59d1c24f-50f1-401a-b101-f33e0daed443-SecureBootEnforce
8be4df61-93ca-11d2-aa0d-00e098032b8c-ConOut
8be4df61-93ca-11d2-aa0d-00e098032b8c-Boot0006
8be4df61-93ca-11d2-aa0d-00e098032b8c-Timeout
a9b5f8d2-cb6d-42c2-bc01-b5ffaae4335e-PBRDevicePath
36d08fa7-cf0b-42f5-8f14-68df73ed3740-PreviousBoot
8be4df61-93ca-11d2-aa0d-00e098032b8c-Boot0005
8be4df61-93ca-11d2-aa0d-00e098032b8c-Boot0004
a56074db-65fe-45f7-bd21-2d2bdd8e9652-LegacyDevOrder
bbd1fd65-5668-4fb2-8999-231095717a07-VBiosInfo
d719b2cb-3d3a-4596-a3bc-dad00e67656f-dbx
5432122d-d034-49d2-a6de-65a829eb4c74-MeSetupStorage
4570b7f1-ade8-4943-8dc3-406472842384-PchSetup
5432122d-d034-49d2-a6de-65a829eb4c74-MeSetup
b08f97ff-e6e8-4193-a997-5e9e9b0adb32-CpuSetup
ba57e015-65b3-4c3c-b274-659192f699e3-BugCheckCode
ba57e015-65b3-4c3c-b274-659192f699e3-BugCheckParameter1
ba57e015-65b3-4c3c-b274-659192f699e3-BugCheckProgress
eaec226f-c9a3-477a-a826-ddc716cdc0e3-OfflineUniqueIDEKPubCRC
eaec226f-c9a3-477a-a826-ddc716cdc0e3-OfflineUniqueIDEKPub
eaec226f-c9a3-477a-a826-ddc716cdc0e3-UnlockIDCopy
77fa9abd-0359-4d32-bd60-28f4e78f784b-CurrentPolicy
59d1c24f-50f1-401a-b101-f33e0daed443-certdb
9669e125-fedf-43f7-891a-5af85efcdefc-L05OkrData
9c57c6e2-4c78-42d9-9051-96b9d80c9c92-BiosGuardStatus
103fcd92-a4e6-4a07-b458-f78c9db45256-PdtUpdVersion
04b37fe8-f6ae-480b-bdd5-37d98c5e89aa-VarErrorFlag
973218b9-1697-432a-8b34-4884b5dfb359-S3MemVariable
8be4df61-93ca-11d2-aa0d-00e098032b8c-Boot2003
8be4df61-93ca-11d2-aa0d-00e098032b8c-Boot2002
8be4df61-93ca-11d2-aa0d-00e098032b8c-Boot2001
41be3a6f-4f29-c80f-1eb6-7c8e97e629d8-LcfcI2cTouchPadId
b2b7c21f-1786-4a64-be69-16cef7647331-SwitchableGraphicsVariable
8be4df61-93ca-11d2-aa0d-00e098032b8c-ConIn
f24643c2-c622-494e-8a0d-4632579c2d5b-TrEEPhysicalPresenceFlags
f24643c2-c622-494e-8a0d-4632579c2d5b-TrEEPhysicalPresence
c60aa7f6-e8d6-4956-8ba1-fe26298f5e87-EPCBIOS
59d1c24f-50f1-401a-b101-f33e0daed443-FirstBootAfterFlash
4da4f952-2516-4d06-8975-65036403a8c7-RstOptaneConfig
a41e9236-4d21-43b5-9379-ddd6fafe6603-Custom
4570b7f1-ade8-4943-8dc3-406472842384-Custom
b08f97ff-e6e8-4193-a997-5e9e9b0adb32-Custom
5432122d-d034-49d2-a6de-65a829eb4c74-Custom
72c5e28c-7783-43a1-8767-fad73fccafa4-Custom
a04a27f4-df00-4d42-b552-39511302113d-Custom
72c5e28c-7783-43a1-8767-fad73fccafa4-SaSetup
59d1c24f-50f1-401a-b101-f33e0daed443-CheckFirstBoot
59d1c24f-50f1-401a-b101-f33e0daed443-CustomPlatformLang
74d69abb-57c3-4d7f-bfb4-26a2549610f1-L05ConfigVar
382af2bb-ffff-abcd-aaee-cce099338877-SecureFlashInfo
8be4df61-93ca-11d2-aa0d-00e098032b8c-PlatformLang
8be4df61-93ca-11d2-aa0d-00e098032b8c-Lang
c020489e-6db2-4ef2-9aa5-ca06fc11d36a-AcpiGlobalVariable
eb704011-1402-11d3-8e77-00a0c969723b-MTC
aeb9c5c1-94f1-4d02-bfd9-4602db2d3c54-Tcg2PhysicalPresence
aeb9c5c1-94f1-4d02-bfd9-4602db2d3c54-Tcg2PhysicalPresenceFlags
59d1c24f-50f1-401a-b101-f33e0daed443-AdministerSecureBoot
59d1c24f-50f1-401a-b101-f33e0daed443-CustomSecurity
59d1c24f-50f1-401a-b101-f33e0daed443-RestoreFactoryDefault
8be4df61-93ca-11d2-aa0d-00e098032b8c-SetupMode
aaf32c78-947b-439a-a180-2e144ec37792-AuthVarKeyDatabase
bb983ccf-151d-40e1-a07b-4a17be168292-MemoryOverwriteRequestControlLock
d719b2cb-3d3a-4596-a3bc-dad00e67656f-db
8be4df61-93ca-11d2-aa0d-00e098032b8c-KEK
8be4df61-93ca-11d2-aa0d-00e098032b8c-PK
```




** Подключаем интернет

`wifi-menu`

Выбираем сеть, вводим пароль.

Проверяем наличие интернет

`ping google.com`

Должны начать выводиться списки загружаемых пакетов

Прерываем и выходим из ping командой ctrl+c






** Синхронизация системных часов

`timedatectl set-ntp true`

** Посмотрим наши старые загрузочные записи (если есть)

`efibootmgr`

```
BootCurrent: 0002
Timeout: 0 seconds
BootOrder: 0002,0006,2001,2003,2002
Boot0002* EndeavourOS
Boot0004* EFI Network 0 for IPv4 (54-E1-AD-42-7A-07) 
Boot0005* EFI Network 0 for IPv6 (54-E1-AD-42-7A-07) 
Boot0006* Windows Boot Manager
Boot2001* EFI USB Device
Boot2002* EFI DVD/CDROM
Boot2003* EFI Network
```




01. Видим, что загрузились через USB UEFI
06. Загрузчик Windows
3. Записи прочих загрузчиков. Если в свое время устанавливались другие дистрибутивы в раздел EFI, то таких записей может быть несколько. В любом случае визуально все можно понять.

Удаляем не нужные записи командой efibootmgr -b x -B,  где x - номер записи в списке по последней цифре. В моем случае это записи 2.


efibootmgr -b 2 -B






** Просмотрим разделы Windows
```
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      8:0    0 931,5G  0 disk 
├─sda1   8:1    0   499M  0 part             среда для восстановления Microsoft
├─sda2   8:2    0    99M  0 part /boot/efi   EFI
├─sda3   8:3    0    16M  0 part             зарезервированный раздел Microsoft
├─sda4   8:4    0 488,5G  0 part             Microsoft basic data
├─sda5   8:5    0   559M  0 part             среда для восстановления Microsoft
├─sda6   8:6    0  70,8G  0 part /           Linux
├─sda7   8:7    0 367,9G  0 part /home       Linux
└─sda8   8:8    0   3,2G  0 part [SWAP]      Linux своп
```

Видим, что раздел EFI находится на /dev/sda2. Сюда будем подключать наш загрузчик.
/dev/sda3 и /dev/sda4 - это, соответственно, диски C и D на Windows.





Разметка диска

`cfdisk`

На свободном месте добавляем разделы

Для root
new 70,8G  type system linux  подтверждаем write
Для swap
new 3.2G  type linux swap  подтверждаем write
367,9G /home
Раздел /dev/sda2 с EFI не трогаем. 
Размер для root и swap, каждый выбирает на свое усмотрение.

Выходим из cfdisk через quit





Получaем разделы
```
root - sda6
boot - sda2
swap - sda8
```
** Форматирование и подключение

#root
mkfs.ext4 /dev/sda5 -L "ARCH"
mount /dev/sda6 /mnt

#home
mkdir -p /mnt/home
mount /dev/sda7 /mnt/home

#boot
mkdir -p /mnt/boot
mount /dev/sda2 /mnt/boot

#swap
mkswap /dev/sda6 
swapon /dev/sda6

Просматриваем и проверяем разделы и подключение

`cfdisk`






Выходим из cfdisk

Обновляем пакеты

`pacman -Syy`

При обновлении пакетов видна скорость скачивания с сервера. Если устраивает,то следующий пункт можно пропустить. 




Настройка сервера загрузки, как пример, для российского сервера.

nano /etc/pacman.d/mirrorlist

Вверху прописываем 
```
## Ukraine
Server = http://archlinux.ip-connect.vn.ua/$repo/os/$arch
Server = https://archlinux.ip-connect.vn.ua/$repo/os/$arch
Server = http://mirror.mirohost.net/archlinux/$repo/os/$arch
Server = https://mirror.mirohost.net/archlinux/$repo/os/$arch
Server = http://mirrors.nix.org.ua/linux/archlinux/$repo/os/$arch
Server = https://mirrors.nix.org.ua/linux/archlinux/$repo/os/$arch
```

Записываем изменения командой ctrl+o 
Подтверждаем enter Выходим из редактора ctrl+x
P.S. Для выбора лучшего сервера по скорости и локализации можно воспользоваться ссылкой https://www.archlinux.org/mirrorlist/








** Устанавливаем базовую систему и пакет для будущего использования AUR.

`pacstrap /mnt base base-devel`

** Генерируем fstab

`genfstab -L -p -P /mnt >> /mnt/etc/fstab`



Просмотрим созданный fstab

`nano /mnt/etc/fstab`




** Переходим в систему

`arch-chroot /mnt` 

Настроим локаль, время, имя компьютера
```
loadkeys ru
setfont cyr-sun16
```

`nano /etc/locale.gen`

Здесь раскомментирум строки
en_US.UTF-8 UTF-8
ru_UA.UTF-8 UTF-8

Записываем изменения командой ctrl+o 
Подтверждаем enter 
Выходим из редактора ctrl+x

`locale-gen`

`nano /etc/locale.conf`

Прописываем строку
LANG=ru_UA.UTF-8

Записываем изменения командой ctrl+o 
Подтверждаем enter 
Выходим из редактора ctrl+x

`export LANG=ru_RU.UTF-8`

`nano /etc/vconsole.conf`

Прописываем строки
KEYMAP=ru
FONT=cyr-sun16

Записываем изменения командой ctrl+o 
Подтверждаем enter 
Выходим из редактора ctrl+x

Настраиваем зону и системное время, как пример, для Россия Москва

ln -sf /usr/share/zoneinfo/Europe/Zaporozhye /etc/localtime

hwclock --systohc

Настраиваем имя компьютера

`nano /etc/hostname`

Прописываем
userhost - имя вашего компьютера

Записываем изменения командой ctrl+o 
Подтверждаем enter 
Выходим из редактора ctrl+x

`nano /etc/hosts` 

Прописываем строчку
127.0.1.1 userhost.localdomain userhost

Записываем изменения командой ctrl+o 
Подтверждаем enter 
Выходим из редактора ctrl+x





Устанавливаем пароль для root

passwd

Здесь же добавляю нового пользователя

`useradd -G wheel -s /bin/bash -m vladimir`
где username - ваше имя пользователя

Открываем права для нового пользователя

`nano /etc/sudoers`

Раскомментируем строку %wheel ALL=(ALL) ALL

Записываем изменения командой ctrl+o 
Подтверждаем enter 
Выходим из редактора ctrl+x




Устанавливаем пароль для нового пользователя

passwd username

Устанавливаем дополнительные пакеты (и пакеты, которые вы считаете нужными)

`pacman -S  efibootmgr iw wpa_supplicant dialog`

Запускаем менеджер загрузки

`bootctl install`

Будут созданы  необходимые директории и точка входа загрузчика




Настраиваем менеджер загрузки

`nano /boot/loader/loader.conf`

Закомментируем все строки, добавим свои
```
default arch                   
timeout 5
editor 1
```
Инфа из WIKI



Получаем



** Создаем файлы конфигурации

Для пользователей процессоров Intel нужно установить дополнительный пакет 
`pacman -S intel-ucode`

`nano /boot/loader/entries/arch.conf`

```
title Arch Linux
linux /vmlinuz-linux
# initrd  /intel-ucode.img       # раскомментировать для пользователей Intel
initrd /initramfs-linux.img
options root=/dev/sda6 rw
```
Здесь sda6 - это наш примонтированный root раздел

Просмотрим последовательность при запуске системы


`efibootmgr`

Установим выбранную последовательность загрузки 

efibootmgr -o 0,6,4,1  # в моем случае Arch будет первым





Выходим

`exit`

Отмонтируем диски

`umount -R /mnt`


Перегружаемся

`reboot`








Базовая система установлена. Остальное  устанавливаем н

* Как я устанавливал Arch Linux на свой ноутбук | Записки программиста
* Chroot на практике
 Chroot на практике

 Chroot на практике
===============
unix-lab.org <https://www.unix-lab.org/posts/chroot/>

3-4 минуты
------------------------------------------------------------------------

Изменение корня это процесс изменения видимой на диске корневой
директории (и текущего запуска процессов) на другую корневую директорию.
Когда вы изменили корневую директорию на другую, вы больше не имеете
доступа к файлам и командам за пределами этой директории. Эта директория
становится подобна заключению пользователя в клетку. Изменение корневой
директории обычно нужно для таких задач как переустановка GRUB или сброс
забытого пароля и чаще осуществляется при помощи LiveCD или LiveUSB в
монтируемый раздел, содержащий установленную систему.

Вы должны загрузиться с любой работающей среды Linux (например, с LiveCD
или USB flash disk). Для работы с chroot потребуются привилегии
суперпользователя.

Убедитесь, что архитектура среды Linux, с которой вы загрузились
соответствует архитектуре системы, с которой вы будете работать (т.e.
i686, x86_64). Вы можете просмотреть архитектуру среды командой: |uname -m|


**    Монтирование каталогов

Чтобы просмотреть все имеющиеся дисковые разделы и их типы введите:
`lsblk`

Создайте директорию, куда вы хотели бы подмонтировать устройство или раздел:
```
# mkdir /mnt/arch
# mount /dev/sda3 /mnt/arch
```


**    Изменение корневой директории

Подмонтируйте временные файловые системы:
```
# mount -t proc none /mnt/arch/proc
# mount -t sysfs sys /mnt/arch/sys
# mount -o bind /dev /mnt/arch/dev
```

**    Монтируйте другие разделы, если нуждаетесь в них (такие как |/boot, /var, /usr|). Например:
```
# mount /dev/sda1 /mnt/arch/boot
```

После выхода из изолированной среды, вы сможете отмонтировать все
разделы одной командой. Это позволит безопасно отключить систему.

Если при нахождении в среде chroot вам нужна будет работа в сети,
скопируйте информацию о DNS в новый корневой каталог:
```
# cp -L /etc/resolv.conf etc/resolv.conf
```

**   Переходим в новую среду:
```
# chroot /mnt/arch /bin/bash
```

Если вы увидите ошибку `"chroot: cannot run command '/bin/bash': Exec format error"` это может означать, что архитектуры не совпадают.

При работе с GRUB в изолированной среде нужно быть уверенным, что каталог `/etc/mtab` содержит актуальную информацию:
```
# grep -v rootfs /proc/mounts > /etc/mtab
```

**   Следующие шаги:
```
# source /etc/profile
# export PS1="(chroot) $PS1"
```


**    Обслуживание системы:

  <     Вот то, что вы можете сделать в изолированной среде:  >

      1. Обновить или откатить пакеты
      2. Пересобрать образ initcpio
      3. Сбросить забытый пароль
      4. Исправить /etc/fstab
      5. Переустановить GRUB


**    Выход из chroot окружения:

Когда вы закончите работу, выйдите из chroot, введя команду `exit`.

Теперь отмонтируйте устройства и каталоги, которые вам больше не нужны:
```
# umount {proc,sys,dev,boot...}
```

Наконец отмонтируйте ваш жёсткий диск:
```
# cd /
# umount /mnt/arch
```

Если вы видите ошибку подобную этой: `"/mnt (или другой каталог) is busy"`, вы можете узнать причину (используя |lsof|) или принудительно отмонтировать каталог:

После этого вы сможете безопасно отключить систему. ⤧





