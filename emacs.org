

#+TITLE: Мои заметки
#+AUTOR: В.И.Шипилов

-Emacs
* emacs      



Орг]] — одна из наиболее интересных возможностей Емакс.  Орг работает со
структурированным гипертекстом и позволяет выполнять различные задачи:
 - управление персона(global-set-key (kbd "C-x C-g") 'deft-find-file)льной информацией (планирование, заметки и др.),
 - подготовка документов,
 - создание презентаций,
 - обработка данных (электронные таблицы и встроенные фрагменты кода
   на различных языках),
 - создание веб-страниц и ведение блога,
 - [[https://ru.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D0%BC%D0%BE%D1%82%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5][грамотное программирование]].

**  10 способов улучшитьи вашу работу с Emacs


- Note taken on [2018-02-15 Чтв 10:49] \\
  Emacsлучший в мире текстовый редактор. Он лучший не только для редактирования исходников программ, он лучший для любого редактирования текста. Научившись работе c Emacs, вы будете эффективно писать, работать с email, документами, блогами, страничками, файлами и фактически со всем остальным, что связанно с набором текста.

  Советы в этом небольшом документе предназначены для достаточно опытных пользователей Emacs. Вы должны быть знакомы с основами работы в Emacs и уже должны знать как редактировать файл .emacs и как искать ошибки (или искать знакомого гуру Emacs) если что то идет не так.

  Не все советы связаны с настройкой Emacs, некоторые из них это настройки для вашего рабочего окружения (desktop environment), для того, что бы работа с Emacs стала более гладкой.

  Ключом к пониманию Emacs является то, что все должно быть эффективно, в том числе экономия движений. Любой опытный музыкант скажет вам, что экономия движений очень важна для того, чтобы стать мастером мирового уровня. Любое ненужное движение это потраченная впустую энергия и неважные результаты.

  Использование мыши это почти всегда наихудшее нарушение экономии движения, потому что вы должны поднять вашу руку, взять мышь и двигать её. Мышь это медленный инструмент, и гуру Emacs считают ее использование ненужной тратой времени.

  По сравнению с Волшебниками Emacs, пользователи графических сравнимы с музыкантами любителями, скребущими свои инструменты с некоторой долей расстройства. манит огнями и красивыми диалогами, от которых нет никакого толка (см. Совет №6), и дает новичкам чувство, что у них все под контролем. Но этот контроль очень иллюзорен и все серьезные программисты предпочитают что-нибудь, что дает им больше возможностей.

  также предлагают инструменты для рефакторинга, которые очень популярны, потому что помогают автоматически исправить ваш кривой код. Это хорошо, пока это работает, но я вам открою один секрет: инструменты для рефакторинга не понимают английский язык. Они не помогут вам ни капли, когда вы пытаетесь сделать что-то, для чего они не предназначены. Emacs предлагает вам новый уровень высокого контроля над вашим кодом, это делает вас готовым к любым трудностям.

  Тем не менее, как я часто указываю, необходимо это увидеть, для того чтобы в это поверить, и даже тогда, когда вы в это поверите, вам необходимо затратить серьезные усилия для профессионального освоения Emacs. Профессиональное освоение, включает в себя изучение Lisp и настройку Emacs, до такого превосходного уровня, который себе можно только представить. Все это служит лишь для того, чтобы утолить Ваш голод в большем контроле и автоматизации, так что даже если вы освоили Emacs, вы никогда не закончите расширять его.

  Это редактор не для слабых духом и этот блог предназначен для людей, которые уже затратили определенные усилия и хотят улучшить свое мастерство в этом элегантном бессмертном софте.

  Остальным: Я думаю ваш Eclipse наконец загрузился и вы теперь можете вернуться к работе.
  ##Совет №1: Поменяйте местами Caps Lock и Control.

  На клавиатурах в Windows и Mac, клавиша Control расположена неудобно, слева в дальнем нижнем углу. В Emacs она используется все время, так что вы никогда виртуозно не освоите Emacs, если не переместите ее в более удобное место. Эта позиция должна быть как можно ближе к рукам, Caps Lock это лучший выбор. Именно по этой причине там находится Control на большинстве клавиатур от Unix workstation.

  Для того чтобы это сделать в Windows 2000 или XP, потребуется залезть в реестр. В меню Start выберите Run и введите regedit. В левой панели кликните по:

  ```
  HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout
  ```

  Нажмите на KeyboardLayout чтобы переместить на него фокус. Убедитесь что фокус на KeyboardLayout и не находится на одной из вложенных в него веток. В меню Edit выберите New Binary Value, назовите новый ключ Scancode Map и укажите тип _BINARY.

  Выберите ключ Scancode Map который вы создали и из меню Edit (его содержание должно изменится), выберите Modify Binary Data. В диалоговом окне нажмите Edit Binary Value и введите данные указанные ниже:

  ```
  0000: 00 00 00 00 00 00 00 000008: 03 00 00 00 3A 00 1D 000010: 1D 00 3A 00 00 00 00 00
  ```

  Выберите OK для того что бы закрыть диалоговое окно, потом закройте Редактор Реестра. Клавиши Caps-Lock и Control должны будут поменяется когда вы выйдите из системы и зайдете обратно. Возможно потребуется перезагрузка системы.

  На Linux в X-Window, вы должны использовать утилиту xmodmap. Создайте файл .xmodmap в вашем домашнем каталоге если он еще не существует, и добавьте в него эти строчки:

  !! Swap Caps_Lock and Control_L!remove Lock = Caps_Lockremove Control = Control_Lkeysym Control_L = Caps_Lockkeysym Caps_Lock = Control_Ladd Lock = Caps_Lockadd Control = Control_L

  Сохраните его, и добавьте строку xmodmap ~/.xmodmap в файл ~/.bash_profile.

  В Mac (Panther и Jaguar) вы должны установить модифицированный драйвер клавиатуры. Это немного страшно, но я думаю проблем не будет. Вот обсуждение драйвера. Другой путь, если вы не используете Mac laptop, кажется существует файл который вы можете редактировать под root, здесь описание как это сделать.

  По этому находится немного информации для других систем.
  ##Совет №2: Используйте M-x без клавиши Alt.

  Alt-x это одна из самых часто используемых горячих клавиш в Emacs, из за этого ваша левая рука устает от постоянных перемещений. То, что вы делаете помногу раз, должно быть оптимизировано, значит, вам необходимо начинать последовательность с клавиши (только если вы последовали совету №1)

  Другая очень важная причина взять привычку использовать : клавиша может быть недоступна на нестандартных платформах и ее поведение может меняется от системы к системе. В частности, когда вы заходите на удаленную машину, используя telnet или ssh, будет работать или не будет, зависит от типа системы и конфигурации терминала. Вместо того, что бы ломать голову вопросом Как заставить работать Alt? и изучать настройки каждой машины с которой вы сталкиваетесь, проще использовать клавишу которая доступна всегда.

  Горячая клавиша, которую я использую это Ctrl-x Ctrl-m. Заметьте, когда вы используете последовательность из 2-x команд с одинаковым модификатором, вы должны нажать и удерживать клавишу с модификатором, затем нажать на 2 оставшиеся клавиши. Так с этой последовательностью: нажмите и удерживайте , нажмите , потом нажмите на .

  Для использования Ctrl-x Ctrl-m добавьте эти строчки в файл .emacs:

  (global-set-key "\C-x\C-m" 'execute-extended-command)(global-set-key "\C-c\C-m" 'execute-extended-command)

  Я добавил вторую строку, чтобы использовать Ctrl-c Ctrl-m. Если промахнусь и вместо Ctrl-x случайно нажму Ctrl-c, ничего страшного не случится. Ни одно из этих сокращений не используется в Emacs по умолчанию, таким образом, вы не отмените любую другую полезную команду.

  Потренируйтесь использовать эту горячую клавишу, пока не привыкните, и тогда Alt-x больше не потребуется. (Вы будете все еще использовать клавишу для других команд, про которые я расскажу позже)

  Кстати, если вы хотите довести эту настройку до экстраординарного уровня, тогда вероятно не захотите использовать безымянный палец для нажатий на клавишу когда набираете Ctrl-x. Я использую левый указательный палец, но вы наверное используете ваш левый средний палец. Причина то, что ваша рука находится не в оптимальном положении, когда левый мизинец нажимает клавишу Caps Lock из которой вы сделали . Смысл в том, что бы использовать все необходимое для того, чтобы не тянуться и как можно меньше шевелить пальцами.

  Поэкспериментируйте пока не найдете то, что наиболее комфортно для вас.
  ###Совет №3: Используйте backward-kill-word вместо Backspace.

  Wizardы Emacs стараются избежать нажатий на клавишу Backspace, потому что она достаточно далеко от стандартного расположения, это раздражает. Мы делаем ошибки при печати все время, но если вы печатаете быстрее 50 знаков в минуту, более экономно удалить все слово и перепечатать его, чем исправлять ошибку с помощью Backspace.

  Вот то, что вы добавите в ваш файл .emacs:

  (global-set-key "\C-w" 'backward-kill-word)(global-set-key "\C-x\C-k" 'kill-region)(global-set-key "\C-c\C-k" 'kill-region)

  Обратите внимание, потому что Ctrl-w уже был связан с kill-region (а это очень важная команда) вам необходимо связать какую ни будь клавишу с kill-region. Я выбрал Ctrl-x Ctrl-k (и ее аналог для неакуратных Ctrl-c Ctrl-k), прежде всего потому, что этот способ использовался на моей старой работе, которая была заполнена мудрыми гуру Emacs, они дали мне многое из того, что я знаю. Переопределив Ctrl-x Ctrl-k, вы больше не сможете использовать edit-kdb-macro, но понадобится она не часто, так что скучать по этому хоткею не придется.

  Дополнительная выгода, во многих командных оболочках(command shells) Unix используются горячие клавиши как в Emacs и Ctrl-w обычно по умолчанию закреплено за backward-kill-word. Таким образом, вы будете последовательными при использовании командных оболочек (command shells).

  Чем быстрее вы печатаете, тем более полезным будет этот совет. Вы понемногу разовьете способность для быстрого исправления и коррекции различных ошибок при печати. Вообще, вот как мои пальцы работают изо дня в день:

      Если я неправильно напечатал один или два символа в длинном слове, и курсор все еще справа от опечатки, тогда я использую клавишу Backspace.
      Если опечатка находится где то в последних 15-20 символах на тоже строке, я обычно использую backward-kill-word для удаления позадистоящих символов до опечатки, и перепечатываю заново.
      Если опечатка позади, но все еще на этой же строке, я использую Alt-b для возвращения курсора назад к слову с опечаткой, и Ctrl-b что бы переместить это внутрь слова к опечатке.

  Для ошибок, находящихся далеко, я использую Быструю Навигацию (Fast Navigation) которая здесь: Совет №4 включает небольшую часть этой техники.

  Одно замечание, вы должны быть очень осторожными, если будете использовать Ctrl-w для backward-kill-word: Ctrl-w используется для закрытия окна в большинстве Windows приложений.
  ##Совет №4: Используйте поиск по мере ввода для Навигации.

  Эффективное перемещение курсора один из ключевых навыков для того, чтобы стать Волшебником Emacs. Пользователи тратят много своего времени, возясь с мышью. Они и не мечтают ни о чем другом, но они не понимают, насколько не эффективны их движения. В руках Мастера, Emacs становится самым мощным и эффективным инструментом для редактирования текста на во всем мире, потому что позволяет вам делать почти все, не используя мышь.

  Волшебники Emacs всегда делают сессии Emacsa такими высокими, насколько это возможно, заполняя экран вертикально, потому что вертикальное пространство самое лучшее, когда вы просматриваете документ. Тогда вы можете увидеть больше строк текста на экране за раз. Использование поиска по мере набора часто самый быстрый способ для точного позиционирования курсора.

  Заведите привычку использовать Ctrl-r (isearch-backward) и Ctrl-s (isearch-forward) для перемещения по документу. Всякий раз, когда вам необходимо переместить курсор назад или вперед больше чем на 5 строк, и вы можете видеть нужное место, нужно использовать i-search.

  Что бы использовать это эффективно, вы не обязательно должны искать точное слово там, где хотите поместить курсор. Позвольте вашему глазу немного расфокусироваться, посмотрите на весь параграф или область вокруг цели, и выберите слово, которое выглядит достаточно уникальным или которое легко напечатать. Тогда воспользуйтесь i-search для перемещения к нему. Возможно потребуется нажать на Ctrl-r или Ctrl-s несколько раз, если ключевое слово окажется не уникальным. Но Emacs подсветит вам все совпадения, так что если их будет несколько Ctrl-g остановит поиск, и вы сможете выбрать другое ключевое слово.

  Трудно выразить, насколько полезна эта техника, как только вы ее освоите. Обучение просто потребует, что бы вы повторяли это, пока ваши пальцы не начнут работать автоматически. Emacs в конечном счете станет продолжением вашего тела, и вы будете выполнять сотни нажатий на клавиши не задумываясь о них. Это сопоставимо сотне навыков, которые вы приобретаете, чтобы хорошо управлять автомобилем.
  ##Совет №5: Используйте временные буферы.

  Одно из самых больших достоинств в Emacs это возможность быстро создать новый буфер, который не будет связан с файлом или процессом. Как только вы привыкните использовать эту возможность, вам будет ее очень не хватать в других редакторах и приложениях.

  Что бы создать временный буфер, просто переключитесь в него! Ctrl-x b запускает команду switch-to-buffer, и вы просто печатаете adsflj или любой другой текст. Тут же у вас появляется блокнот, где можно оставить заметки, свалить временные результаты, или использовать его как удобный инструмент для решения других проблем.

  Если планируете использовать несколько временных буферов, давайте им более запоминающиеся имена, например foo, bar, baz или buh.

  Если захотите посмотреть временный буфер вместе с другим буфером, то можете разделить экран по горизонтали или вертикали. Смотрите Совет №6.

  Поскольку ваши временные буферы не связаны с файлом, их можно удалить так же быстро, как и создать, используйте для этого Ctrl-x k (команда kill-buffer).

  Если решите где-нибудь сохранить содержимое временного буфера, просто переключитесь в него и нажмите Ctrl-x Ctrl-w для выполнения команды write-file. Вам нужно будет ввести имя файла, и после сохранения можете безопасно удалить буфер и вернутся к файлу позже.
  ##Совет №6: Освойте команды для управления буфером и окном.

  Вам часто будет необходимо работать с текстом и иметь несколько открытых окон. По сравнению с другими приложениями в Emacs используется немного другая терминология, буфер (buffer) это логическое пространство, содержащее какой либо текст, возможно связанный с файлом или процессом. Окно (window) это видимая область экрана, отображающая ровно один буфер (или его часть). Фрейм (frame) это то, что называется окном (window) на жаргоне операционной системы: отдельное окно с собственным заголовком и прочими атрибутами.

  Самые необходимые команды для управления окнами и буферами:

      Ctrl-x 2: split-window-verticallyразделить текущее окно на два равных по высоте, показав этот же буфер (пока вы не поменяете один из них на что-нибудь другое).
      Ctrl-x 3: split-window-horizontallyбольшинство людей не часто это используют, но иногда оно полезно. Разделяет окно пополам, на левую и правую часть.
      Ctrl-x +: balance-windowsделает все открытые окна приблизительно равными по высоте. Это полезно если вы только что нажали Ctrl-x 2 дважды, потому что получите два окна 1/4 по высоте и одно окно 1/2 по высоте. Ctrl-x + сделает все окна равными по высоте.
      Ctrl-x o: other-windowперемещает курсор в следующее окно из списка окон, это обычно означает перемещение в окно которое ниже текущего, или возврат на самый верх списка.
      Ctrl-x 1: delete-other-windowsзаставляет текущее окно, на котором находится фокус, раскрыться на весь фрейм, остальные окна будут скрыты и останутся доступными в списке окон, так что эта команда всегда безопасна.
      Ctrl-x Ctrl-b: list-buffers показывает список всех буферов которые вы открыли в красиво отформатированном буфере с именем Buffer List. В нем доступно много полезных горячих клавиш для управления списком буферов. Например, нажмите когда курсор находится на одном из них, это отметит этот буфер для удаления, удалит буфер, и так далее. Используйте M-x describe-bindings для просмотра всех горячих клавиш доступных в Buffer List.

  ##Диалоговые Окна: Корень Всего Зла.

  Emacs невероятно мощный текстовый редактор, но некоторые дизайнерские решения особенно выделяются. Одно из них то что в Emacsе нет диалоговых окон. Это фактически было одно из требований, что бы дать Emacs полную функциональность при работе в текстовом терминале. Но по счастливой случайности, это так же одна из ключевых возможностей, которая помогает сделать Emacs безумно мощным.

lkjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj  Диалоговые окнаотстой. Для начинающих они всегда создают проблемы с фокусом, часто блокируют криво сделанные приложения или не дают работать, пока диалоговое окно открыто. И они, кажется, никогда нормально не работают с любыми нестандартными видео режимами. Для примера, если вы используете для работы два монитора, диалоговое окно в приложениях Windows будет иметь тенденцию выскочить не на том мониторе, вызывая гемморой.

  Диалоги иногда появляются в непредсказуемых местах даже на машинах с одним монитором. И даже в хорошо сделанных приложениях, таких как Microsoft Office модальные диалоги могут вылезти позади текущего окна, и складывается такое ощущение, что приложение повисло, до тех пор пока вы не найдете этот проклятый диалог и не вытащите его наверх.

  По некоторой странной причине у диалоговых окон часто невозможно изменить размер. Окна приложений напротив, почти всегда могут менять размер и дизайнеры обычно прилагают большие усилия, для того чтобы заставить UI перестроится и занять все свободное место, когда вы изменяете размеры окна. Но с диалогами все по другому, по умолчанию у них нельзя изменить размеры, возможно потому, что на большинстве ОС диалоги это грязный хак, который был добавлен намного позже оконных менеджеров сделанных совсем без диалогов (я так предполагаю). Черт, они изгадили даже Java Swing.

  И не просите меня рассуждать о кнопках. Мы имеем диалоговые окна в на протяжении последних 25 лет, но люди все еще не могут договорится о стандартном наборе кнопок для них, или даже о стандартном месте для их размещения. Некоторые диалоги помещают их в заголовок окна, некоторые в низ, некоторые на правую сторону. И редко на 100% ясно что случится если вы используете контрол в заголовке окна для закрытия диалога, проигнорировав кнопки на самом диалоге. Весь опытэто гигантский дерьмовый сандвич, и все знают это интуитивно, но каждый предполагает по своему.

  Но проблемы с диалоговыми окнами еще глубже чем фокус, размеры и позиционирование. Диалоги никогда полностью не являются частью UI приложения. Если вы создали клавиатурный макрос (не обязательно в Emacs – в любом другом приложении, например Excel или Word), то он не будет работать в окне диалога. Если диалог имеет scrollable widget, вы не имеете никакой возможности для навигации кроме как использовать полосу прокрутки.

  Для иллюстрации, запустите Internet Explorer и выберите Internet Options из меню Tools. Перейдите на закладку Advanced. Все там: все ваши жалкие глобальные настройки для IE. Если вы хотите найти специфическую настройку, вы должны медленно листать, ища ее. Вы не можете воспользоваться Edit/Find, потому что диалог конечно, модальный и диалог, конечно, не меняет размер. Большинство диалогов похожи на него.
  Буферы это Спасение.

  В Emacs весь вывод направляется в буферы, а все буферываши лучшие друзья. Ваши любимые горячие клавиши для навигации доступны во всех буферах, включая i-search. Вы можете выбрать и скопировать текст из любого буфера и нет таких вещей, как модальный буфер, таким образом, вы можете сохранять его так долго как хотите, пока продолжаете работать в других окнах. И он не обязательно должен быть видимым, диалог будет в списке буферов, пока вы не отклоните его.

  Ничего подобного буферам в Emacs нет ни в одном приложении. Как только вы поймете, насколько сильна и мощна эта модель, все остальные приложения станут немного неприятными, потому что вы поймете, что их UIтолько приближаются к тому, с чем вы уже работаете.

  Как только вы научитесь мастерству владения этими буферами и окнами, и научитесь бросать их вокруг с легкостью, вы станете на шаг ближе к тому, чтобы стать Волшебником Emacs.
  ##Совет №7: Освободите UI

  Вам не нужен менюбар. Это костыль, размещенный для дезориентированных новичков. Вам также не нужен тулбар с красивыми иконками, и полоса прокрутки не нужна. Все эти вещи для лузеров, и они только занимают драгоценное место на экране. Выключите их добавив этот код в ваш файл .emacs:

  ```
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))(if (fboundp 'menu-bar-mode) (menu-bar-mode -1))

  ```
  Вы не ничего из этого не потеряете. Мы расскажем, как обходится без них в следующем совете.

  (Примечание от 2 января 2006) Я недавно видел комментарий от человека который ненавидел все это эссе из-за совета №7. Он высказывал много раздражения, будучи сильно привязанным к своей мыши и меню, и обиделся за то что его назвали дезориентированным новичком. Человек упорно утверждал, что использование мыши быстрее и это было доказано многочисленными исследованиями, таким образом, я должен внести некоторые уточнения и продолжить этот совет. Спасибо раздраженному читателю блога.

  Сначала я должен заметитьмне жаль что Emacs не имеет более богатых возможностей для отображения, дающих ему и графику как в остальных приложениях. Возможно, она никогда не появится; моя шумная статья в блоге The Emacs Problem немного говорит об этом. Но все-таки я хотел бы это увидеть. Я указываю на этот факт, как на свидетельство того, что я не безрассудный анти-GUI человек.
  Полоса прокрутки не обязательна

  Я обычно выключаю полосу прокрутки в Emacs, потому что есть горячие клавиши, которые дают тот же эффект. Однако полосы прокрутки дают преимущество аналоговой обратной связи, указывая, где в буфере вы находитесь и насколько далеко. Цифровая обратная связь обеспечивается %-индикатором в статусной строке, его не всегда просто прочитать – доказано множеством исследований. Именно поэтому U.S. Navy используют аналоговые датчики в реакторных установках. Слишком просто скользнуть взглядом по цифровому (т.е. числовому) датчику и не понять его.

  Таким образом, нет никаких проблем с полосами прокрутки, если вам с ними более комфортно. Только знайте, что это заставит вас использовать мышь, но для определенных операций (например: переход на начало или конец буфера) клавиатура гораздо быстрее. Никакие исследования не подтвердят это. Немного простых экспериментов убедят даже самого скептически настроенного читателя. Клавиатура выигрывает при навигации.

  Допустим, мы хотим поместить строку из 80 дефисов в самое начало и самый конец большого буфера, а вы находитесь в середине буфера. Это немного неестественно, но я делал это, когда необходимо было вставить “cur here” вокруг текста содержащегося в буфере. Я закончил менее чем за 3 секунды и был готов перейти к следующий задаче. Клавиши, которые я должен был нажать C-x t C-u 8 0 Cx e C-u 8 0

  Не существует простого способа сделать это за 3 секунды с мышью, так как вы должны будете сделать мышью 2 полных перемещения в оба конца, взяв за полосу прокрутки и перетащить ее вверх или вниз, затем вернутся к клавиатуре, чтобы напечатать текст. Небольшой эксперимент завершился за 15 секунд. Прокрутка в начало НЕ перемещает курсор на первую букву, так что вы должны аккуратно позиционировать курсор.

  Несомненно, вы могли бы попрактиковаться, и тогда, возможно, вы возможно уложитесь в 10 секунд, но зачем беспокоится? Если собираетесь часто использовать эту операцию, вы должны для нее написать макрос.
  Случай использование мыши #1 из 1: выбор области (region selection)

  Конечно, ясно, что существуют операции, которые с помощью мыши будут выполняться быстрее. Взаимодействие с вашей системой вне Emacs обычно быстрее с мышью и работа с остальными приложениями, которые не имеют возможностей Emacs для навигации с помощью клавиатуры. Но внутри Emacs, я могу представить только один случай, когда мышь будет быстрее: выбор области (region selection), особенно если вы выбираете прямоугольник.

  Иногда выбор области с помощью клавиатуры быстрее: например, установить метку (mark) и нажать Ctrl-n для начала выбора строк, или Ctrl-f для увеличения выбранной области посимвольно. Но у клавиатуры низкая скорость повторения (repeat rate) которая может быть раздражающе медленной. Я могу увидеть более 100 строк текста на моем экране и выбрать эти строки с клавиатуры (предполагая, что начну, откуда-нибудь из середины) это займет около 5 секунд. На выбор с помощью мыши и возвращение потребуется 4 секунды. Так что когда мне нужно выбрать строки в видимой области, мышь обычно не требуется.

  Но если мне нужно выбрать область большую, чем размер экранатогда мышь это наиболее надежный и быстрый инструмент, и я буду с удовольствием ее использовать.

  Использование мыши для выбора (selections) не освобождает UI, это мало связано с этим советом. Дело в том, что я нередко провожу такие эксперименты, как этот. Мое мнение о в Emacs подтверждено 20 годами таких экспериментов. И я советую отключить меню. Действительно.
  Меню: уберите это!

  Меню хороши для изучения, чтобы узнать больше о возможностях Emacs. К сожалению, они могут легко запутать вас относительно его возможностей. Однако множество пакетов Emacs’а не имеют никакой поддержки меню – только очень дотошные разработчики его добавляют. Так что, если вы используете меню для исследования Emacs, вы можете пропустить много функциональности.

  Другая проблема меню связана с тем, что я раньше говорил о диалоговых окнах: они не масштабируются. Если захотите дать пользователю выбор из 1500 элементов поместив их в меню, скорее всего не сможете это сделать из за лимитов оконной системы (windowing system). Используя буферы Emacs это можно сделать тривиально, к тому же даст вам намного больше возможностей для размещения и группировки элементов. Попробуйте M-x list-colors-display или M-x list-faces-display, чтобы посмотреть примеры того, о чем я говорю.

  Еще одна (огромная) проблема с меню точто оно не доступно для поиска и автозавершения (auto-complete). Вы можете легко уйти глубоко вниз по иерархии меню, думая, что находитесь, где-то рядом, но реально находясь далеко от цели. У меню нет такого гибкого механизма для изучения, как справка с поиском (searchable help), она хороша во всех отношениях и в приложениях Microsoft и в Emacs.

  И наконец, как только вы запомнили как выполнять необходимые действия с помощью меню, всегда придется возвращаться к нужному меню (и возможно подменю) для их выполнения. Чем чаще вы выполняете такие действия, тем больше времени вы теряете по сравнению с использованием горячих клавиш.

  Таким образом, я думаю, что меню в Emacs бесполезны. Они не показывают вам всего того, что может сделать Emacs. Они не дают никакой альтернативы, когда вы что-нибудь не можете найти. Они не могут масштабироваться и показать тысячу элементов (так что они не очень хороший общий UI механизм, по сравнению с tree view или чем-нибудь подобным). И даже когда вы знаете, как пользоваться меню, все равно будете терять время.

  Вкратце: выключите меню! И для больших блестящих кнопок, ну, черт возьми, если кнопка очень необходима, ее всегда можно заменить такой же необходимой горячей клавишей.
  ##Совет №8: Изучите самые важные справочные функции.

  Для того что бы узнать все горячие клавиши, определенные в текущем буфере, введите M-x describe-bindings. Это покажет вам список горячих клавиш и команд, которым они сопоставлены.

  Если переместить курсор на одну из команд из списка, и нажать Enter, тогда увидите справку по этой команде.

  Чтобы узнать, что делает отдельная горячая клавиша, используйте M-x describe-key и затем напечатайте ее. Это отправит вас непосредственно на справку, если горячая клавиша сопоставлена какой-нибудь команде.

  Если вы хотите найти команду и предполагаете, как она называется, но точно не уверены, используйте M-x apropos, введите регулярное выражение (см. Совет №9) для поиска нужной команды. Все команды Emacs (а также переменные функций и списки свойств) находятся в глобальной таблице в которой можно искать, используя M-x apropos.

  Если, например вы хотите найти функцию которая оправляет буфер в конец списка буферов, вы должны выполнить M-x apropos-commаnd buffer, это покажет вам около 200 доступных команд в названии которых есть слово “buffer”. Где-то в начале будет команда bury-buffer, документация к которой говорит

  `bury-buffer M-x bury-buffer RET Command: Put BUFFER at the end of the list of all buffers.`

  Et voila. Это команда, которую вы искали. Вы можете легко фильтровать большое количество результатов поиска указав более точный regexp.

  Возможно самая важная функция Справки это M-x info, которая вызовет интерактивный управляемый с помощью меню движок справки (info) Emacs. Вы должны научиться его использовать. Там находятся тысячи страниц документации с гиперссылками (к сожалению, реализовано другим способом, который предшествовал Web’у), таким образом, навигация удобнее, чем при использовании страниц man. Как только вы научитесь клавишам для навигации в Info, перемещаться по справке будете быстрее, чем по страницам в браузере, частично из-за того, что Info может искать вдоль и поперек по всем файлам, частично потому, что в Emacs возможности для навигации гораздо лучше чем в любом браузере.
  ##Совет №9: Научитесь использовать регулярные выражения в Emacs

  Лучший путь для этого получить книгу Friedl Book, Mastering Regular Expressions. Она стоит того. Каждый программист должен иметь ее, независимо от используемого языка программирования или редактора.

  Регулярные выражения в Emacs имеют некоторые странности, которые никто не любит, но их легко преодолеть, и как только вы научитесь, для вас откроются новые горизонты при редактировании текста.

  Две самые важные команды isearch-forward-regexp и isearch-backward-regexp. По умолчанию они закреплены за и соответственно, эти горячие клавиши кривые. Все горячие клавиши, которым необходимо нажатие Escape – кривые. На моей машине Compaq Alt-Ctrl-s невидима для Emacs, она вызывает диалог “Диагностика системы”.

  У меня команды isearch-* закреплены за Alt-r и Alt-s. Alt-s обычно не используется ни одной командой. Alt-r по умолчанию сопоставлена команде move-to-window-line, но она не потребуется, потому что для перемещений по документу вы будете использовать Совет №4.

  Некоторые режимы редактирования (modes) переопределяют Alt-r и Alt-s, что раздражает, и я вынужден для каждого режима переопределять их заново, но я не могу сделать это для всех сразу. Если кто-нибудь может предложить способ как назначить Alt-s и Alt-r таким образом, что бы они в дальнейшем не могли быть переопределены, пожалуйста, сообщите мне – я буду чрезвычайно благодарен.

  Следующие две важные команды это replace-regexp и query-replace-regexp. Эти функции идентичны, спрашивают регулярное выражение и строку на которую нужно заменить, но query-replace-regexp требует чтобы вы подтвердили каждую замену текста введя y или n.

  Я использую query-replace-regexp настолько часто, что даже создал синоним (alias) для нее.

  `(defalias 'qrr 'query-replace-regexp)`

  Так что я могу напечатать M-x qrr что бы выполнить эту функцию.

  Другие полезные команды это M-x list-matching-lines, которая показывает вам все строки в буфере, которые подпадают под регулярное выражение. И M-x apropos, которая показывает все команды, названия которых соответствует указанному регулярному выражению.

  Самый Часто Задавемый ВОпрос о регулярных выражениях в Emacs: “Как вставить символ новой строки в регулярное выражение или строку замены?” Нажатие на Enter просто говорит команде, что вы закончили вводить regexp, и начали печатать строку замены. (Это очень серьезное основание для того, что бы предпочесть query-replace-regexp вместо replace-regexp, пока вы не на 100% уверены что ваши regexp правильные.)

  Ответ – вы должны вставить символ ^ J, который используется в Emacs для обозначения перехода на новую строку в функциях и командах. При вводе regexp или строки для замены, когда нужно вставить новую строку, нажмите Ctrl-q, а затем Ctrl-j. Ctrl-q это команда “quote” : вместо выполнения следующей команды, Emacs вставит код клавиши в текущий буфер или минибуфер (minibuffer).

  Некоторые другие полезные вещи, которые должны знать о регулярных выражениях в Emacs:

      Необходимо использовать двойное экранирование (\\) специальных символов в строках внутри elisp кода, но при вводе regexp в минибуфере нужно использовать одинарное экранирование (\).
      В коде Emacs очень часто используются ( и ), так что в регулярных выражениях в Emacs ( и ) имеют другое значение. ( и ) обозначают соответствующий символы, в то время как \( и \) используются для обозначения групп (matching groups).
      В строке для замены нужно использовать \1, \2, и т.д. для вставки групп (match-groups) из регулярного выражения.
      Если вы вводите regexp и он не работает, отмените результат работы команды если текст был изменен. Вызовете команду снова. При вводе параметров используйте клавиши up и down для того, что бы найти ваш regexp и строку замены, и измените их. Это поможет избежать лишних действий.
      Вы можете вставлять текст из буфера обмена при вводе regexp в большинстве regexp команд, но НЕ в командах isearch- * -regexp. Вставка текста из буфера обмена там работает очень странно. Я хотел бы знать, как это поправить.

  Освоение регулярных выражений и команд которые их используют, одна из самых важных вещей на пути эфективного использования Emacs.
  ##Совет №10: Научитесь полезным командам для работы с текстом.

  Emacs предоставляет много мелких, но полезных команд для тонкой работы с текстом. По эффективности они подобны лазеру.

  Для начинающих: не надо пытаться переопределить Ctrl-k, так что бы удалялась вся строка вместе с символом новой строки (include newline). Я знаю, такое поведение kill-line используется во всех других редакторах. Но по сравнению с kill-line, используемой по умолчанию – это неуклюже и грубо. Поведение по умолчанию, когда удаляется текст до конца строки, но не трогается символ новой строки, дает вам более тонкий и точный контроль при редактировании. Доверяйте мне: все пользователи Emacs используют другие приложения, но только поддерживающие emacs-like kill-whole-line, таким образом, они имеют больше возможностей и могут использовать оба способа. Это одна из причин, почему именно так работает Ctrl-k по умолчанию.
  Клавиатурные макросы

  Полагаю, что я могу заявить без всякого преувеличения, что клавиатурные макросы в Emacsэто самая клевая вещь во всем мире. Вы можете создать их на лету для решения специфических проблем при редактировании. Всякий раз, когда необходимо выполнить определенное шаблонное действие больше чем, скажем, 10-15 раз, создайте клавиатурный макрос. Это действительно просто сделать.

  Поместите курсор в начало места которое необходимо изменить, и нажмите Ctrl-x ( для того что бы начать запись макроса. Внесите изменения в текст, и убедитесь что курсор находится на соответствующем месте на следующей строке (или на несколько строк ниже если это необходимо), таким образом, макрос выполнит точно такое же шаблонное действие каждый раз. Для того что бы остановить запись, нажмите Ctrl-x ), и для выполнения макроса используйте Ctrl-x e (call-last-kbd-macro).

  Это почти искусство, определить “устойчивый” макрос: вы должны научится использовать “якоря” такие как “начало строки” и “конец строки”, чтобы убедится что макрос находится в “устойчивой” точке, перед тем как добавить к нему другое действие.

  Так же полезен и incremental-search для того, чтобы переместится к нужному месту и вызвать макрос. Если вы используете isearch внутри макроса, для поиска необходимого места, то в дальнейшем при каждом запуске макрос автоматически повторит поиск. Очень удобно.

  Это нормально – делать небольшие ошибки при навигации в процессе записи макроса. Просто переместите курсор обратно туда, где он должен быть и продолжите запись. Ошибка будет повторяться каждый раз, когда вы будете запускать макрос, но настолько быстро, что вы ее и не заметите.

  Совет для создания хороших макросов один: убедитесь, что ваш макрос будет работать, и не бросайте, даже если для создания макроса требуется больше времени чем, если бы редактировали вручную. В дальнейшем все это станет более простым и в конечном счете, станет вашей второй натурой. Клавиатурные макросы одно и самых мощных возможностей в Emacs и они сделают вашу работу более простой.

  Одна последняя подсказка для клавиатурных макросов: обычно вы запускаете их множество раз или даже сотни раз в одном файле, или в нескольких файлах. Вы должны связать call-last-kbd-macro с одной клавишей, например, такой как . Это можно сделать так:

  `(global-set-key [f5] 'call-last-kbd-macro)`

  Функции transpose-*

  Вы найдете команды transpose- * удивительно полезными, как только привыкните к ним, даже притом, что они похожи на трюки. Вероятно самая полезная команда transpose-words, которая закреплена за Alt-t. Вы были бы поражены, узнав насколько часто ее можно использовать. Она может пригодиться в двух случаях: чтобы поменять местами два смежных слова, или переместить одно слово вперед или назад в предложении.

  Функция transpose-words знает о специфичном для режима синтаксисе и границах слов, так, например, переместив курсор между этими двумя словами:

  `([this])-is`

  и нажав Alt-t, получим такое:

  `([is])-this`

  Вы можете использовать transpose-words в тексте с дефисами, тэгами и другими знаками пунктуации. Это довольно полезная особенность.

  Когда вы перемещаете 2 слова, пр. еда собака, то левое слово поменяется местами с правым (предположим, что курсор находится где-нибудь между началом первого слова и концом второго слова), в результате получим собака еда. Но курсор переместится таким образом, что будет находиться справа от слова, которое переместилось направо. Так если вы повторите это несколько раз, то слово будет перемещаться направо в предложении. Я не думаю, что есть встроенная функция для того что бы переместить-слово-налево, но для этого можно просто написать маленькую функцию. Соответствующий плагин к Eclipse состоял бы из 5,000 строк кода в 60 файлах с исходниками, и потребовалось бы 9 дней для написания и отладки.

  Вы также можете перемещать символы, предложения и параграфы. Они все одинаково полезны, поскольку вы редактируете сырой текст (raw text). Помните о них и экспериментируйте с ними, тогда они тоже станут вашей второй натурой.
  Продолжение следует

  В какой то момент я соберу и напишу 50 советов. Я предпринял отважное усилие чтобы написать их за один присест, но потом бросил и переименовал один из заголовков в этом блоге, с 50 способов улучшить вашу работу с Emacs на 10 способов улучшить вашу работу с Emacs. По крайней мере, эту статью удалось написать немногим более, чем за 2 часа.

  Некоторые советы которые не попали в эту статью, но тем не менее будут очень полезными:

      fill-paragraph (Alt-p)аккуратный перенос строк (line-wrap) в вашем тексте: безспорно очень полезная штука, и она работает внутри коментариев в исходном коде.
      gnuserv: позволяет открыть файл или документ в уже запущенной копии Emacs.
      M-x Dired: полнофункциональный файловый менеджер. Может делать то, что не умеет ни один другой подобный инструмент (по крайней мере из тех которые я знаю), включая переименование произвольных групп файлов по regexp.
      команды whitespace-manipulation: C-x C-o (delete-blank-lines), delete-trailing-whitespace, tabify и untabify, indent-region и другие.
      nxml-mode: ЕДИНСТВЕННЫЙ эффективный способ редактирования файлов. Созданный гуру James Clark, на данный момент он отправляет в нокаут любой редактор.
      picture-mode: лучший инструмент для создания ascii art.
      работа с минибуфером (minibuffer) : научитесь рекурсивному редактированию, узнавайте как выходить из различных ситуаций, использовать автозавершения и другие возможности.
      легкая навигация: переопредилите несколько клавиш, чтобы вы могли переместить курсор на любую позицию, посимвольно или перемещаясь по словам, удерживая и нажимая на различные клавиши.
      region management: выберите подходящие цвета для подсветки области (region), используйте команды для управления областью (region-related).
      rectangle commands: еще один невероятно важный набор команд, которым нет аналогов в других редакторах. Вы опять зададитесь вопросом, как раньше без них обходились.
      emacs shells: советы как использовать команды bash и запускать их подпроцессами в Emacs.
      align-regexp: моя новая любимая команда. Просто узнал о ней недавно и теперь использую ее почти каждый день.
      frame initialization: поместите Emacs на нужное вам место, при каждом запуске он будет автоматически определять размеры экрана и подстраиватся под них.
      использование goal column: это должен знать каждый продвинутый пользователь Emacs.
      настройка fill column: как получить необходимые fill-region и fill-paragraph.
      оптимизируйте настройки ОС, такие как скорость повторения (repeat rate) на клавиатуре, шрифт для Emacs и другие.
      промотр и редактирование архивов: tar, gzip, zip, jar, etc. Большинство пользователей понятия не имеет о этой возможности.
      advanced keybinding: изучите синтаксис для создания горячих клавиши. Научитесь создавать горячие клавиши для определенного буфера или режима.
      изучите Info: настройте ваши Info каталоги, научитесь искать в Info, добавлять туда новые файлы, перемещяться по страницам помощи и делать закладки.
      используйте M-x customize: изучите как оно работает, как им пользоватся и как обходится без него при необходимости.
      полезные приложения: M-x calendar, M-x calc и другие.

  Список можно продолжать бесконечно, я как нибудь найду время для этого.



  Tags:
    emacs

** Org-mode keys
Описание Org Mode

    By Kurlovitsch, www.emacswiki.org
    Посмотреть оригинал
    март 7-го, 2018
    org

Возможности OrgMode:

    позволяет обеспечить структурирование содержимого больших файлов
    редактирование структуры и чередование отображения облегчает работу со структурой документа;
    встроенный редактор таблиц;
    облегченная работа с гиперссылками на вебсайты, посты в Usenet, на файлы

Чередование отображения (Visibility cycling)

Можно сворачивать, разворачивать содержимое разделов

То какой режим отображения будет при загрузке .org файла задается для всей файлов переменной org-startup-folded,
если для каждого файла необходим свой режим отображения то в буфер вносится одна из этих записей:

    #+STARTUP: overview
    #+STARTUP: content
    #+STARTUP: showall
    #+STARTUP: showeverything

Что бы вернуться к заданному отображению используют команду org-set-startup-visibility (C-u C-u TAB)
Перемещение по буферу

    C-c C-n (org-next-visible-heading) Следующий заголовок.
    C-c C-p (org-previous-visible-heading) Предыдущий заголовок.
    C-c C-f (org-forward-same-level) Следующий заголовок того же уровня.
    C-c C-b (org-backward-same-level) Предыдущий заголовок того же уровня.
    C-c C-u (outline-up-heading) Переместиться назад на заголовок более высокого уровня.
    C-c C-j (org-goto) перейти в другое место буфера не изменяя текущего его отображения. 
При нажатии комбинации выводятся клавиатурные комбинации для изменения положения курсора

Редактирование структуры

 M-RET - Вставить заголовок того же уровня, что и текущий. Если курсор находится в начале строки текущего заголовка, 
 то новый заголовок создается перед текущим. 
 Если курсор в середине текущей строки, то создается новый заголовок из той части текущего заголовка, 
 который находится после курсора. Чтобы отключить эту функцию необходимо изменить параметр org-M-RET-may-split-line.
 Если курсор в начале строки обычного текста, то эта строка текста становится заголовком. 
 С префиксом C-u команда вставляет заголовок в конец текущего поддерева. 
 С префиксом C-u C-u команда создает заголовк в конце родительского поддерева.

 C-c C-x C-w (org-cut-subtree) - убить (вырезать) подуровень. 
 С числовым аргументом N убивает N подуровней.

 C-c C-x M-w (org-copy-subtree) - копировать подуровень. С числовым аргументом N копирует N подуровней.
 C-c C-x C-y (org-paste-subtree) - вставить подуровень. 
 Уровень вставляемого блока приводится в соответствие с тем местом в которое он копируется. 
 Можно задать уровень вставляемого блока задав числовой аргумент, 
 или вставляя блок после введенных символов уровня, например, “****”

Простой список

Элементы неупорядоченного списка должны начинаться с символов ‘-’, ‘+’, или ‘*’ 
(При этом если список начинается с символа “*” чтобы его отличить от уровня документа строка должна быть с отступом. 
Элементы упорядоченного списка должны начинаться с цифры за которой следует абзац или круглая скобка. 
M-RET - вставить новый элемент списка
 
Гиперссылки

Имеется возможность создавать гиперссылки, как внутри файла, так внешние ссылки на другие файлы, другие внешние ресурсы.

Формат гиперссылки

Орг распознает URL-ссылки и делает их автоматически кликальными.
По общему правилу формат гиперссылки такой: [[ссылка][описание]] или альтернативный вариант [[ссылка]]. 
Как только завершается ввод текста этого кода в буфер, то есть вводится последняя скобка, 
начинает отображаться ссылка, а не введенный код.
Что бы отобразить код ссылки необходимо убрать закрывающую или открывающую скобку. 
Для этого курсор необходимо поместить в начало или конец отображаемой ссылки и нажать клавишу удаления.

Внутренние гиперссылки

Если гиперссылка не похожа на URL-ссылку то она интерпретируется как внутренняя гиперссылка (в данном открытом файле).
Открыть гиперссылку

    C-c C-o (org-open-at-point)

Список задач (todo list)

    M-shift-RET (org-insert-todo-heading) создать новую задачу.
    C-c C-t - пометить задачу как выполненную

Расширение возможностей Org Mode

org-ref - Развитый инструмент работы с библиографией

Multi-Font Themes in Emacs - Темы с оформлением несколькими шрифтами

#+ATTR_ORG: :width 600
[[file:~/.emacs.d/blog_big.png][image]]

** Emacs, org-mode, мои настройки в .emacs


- Note taken on [2018-02-15 Чтв 11:59] \\
  blog.swlogic.eu
  <http://blog.swlogic.eu/2010/10/09/emacs-org-mode-moj-emacs/>


  ## Emacs, org-mode, мои настройки в .emacs

  Евгений Казанов
  3-4 минуты
  ------------------------------------------------------------------------


  - Emacs, org-mode, мои настройки в .emacs

  На хабре я упомянул, что у меня настроен органайзер на базе org-mode с
  оглавлением в специальном окне. Поступил запрос на опубликование моего
  .emacs. Попытаюсь выделить нужный кусок настроек.


  - Введение

  Мой органайзер построен на основе двух вещей:

    * Org-mode - режим для ведения заметок.
    * Dedicated-mode - режим для прикрепления буфера к окну.


  - Идея

  Начинал я вообще-то с GTD, была расписана процедура, что делать и в
  какой день. В конце-концов от GTD остался список дел.

  С точки зрения польователя, мой органайзер устроен просто. Сейчас я буду
  описывать то, что изображено на Рис. 1:

    * Самое левое окно, вертикальное и узкое. В нем открывается файл
      organizer-links.org. В этом файле только заголовки и ссылки. Окно
      находится в dedicated mode. Поэтому, при переходе по ссылке, файл
      открывается не в этом окне, а в одном из тех, которые находятся в
      свободном режиме. Т.е. буфер файла organizer-links.org всегда на
      виду и в том же самом месте.
    * Верхний ряд, левое окно. В нем открывается файл organizer-daily.org.
      В этом файле список дел. Окно находится в dedicated mode. Т.е. как
      для предыдущего буфера, всегда доступен.
    * Два оставшихся окна. Буфера в свободном режиме. В них попадаем при
      переходе по ссылке.

  Скриншот экрана emacs

  Рис. 1 Экран Emacs в описываемом режиме.


  - Ведение списка дел

  Список дел ведется в org-mode, файл: organizer-daily.org. Заголовки
  первого уровня - даты, второго уровня - дела. Начинается новый день,
  ставим новую дату. Выполненные дела перемещаем выше сегодняшней даты, не
  сделанные - ниже.

  Таким образом текущая дата все время ползет вниз, сделанные дела
  остаются вверху. Скриншот - Рис. 2.

  Emacs: org-mode: organizer-daily.org

  Рис. 2. Ведение списка дел.


  - Код в .emacs

  Примечания к коду:

    * Органайзер я запускаю командой emacs -f my-org.
    * Можно запускать органайзер и из emacs.
    * dedicated.el находится (для Ubuntu) в пакете emacs-goodies-el, или
      можно установаить отдельно, как у меня.

  Код на elisp
  ```lisp
  (load "/home/evgeny/.emacs.d/site-lisp/dedicated/dedicated.el")

  (defun my-org ()
    "Create org-mode windows open files"
    (interactive)
    (setq default-frame-alist
  	`((width . ,140)
  	  (height . ,45)
  	  (top . ,5)
  	  (left . ,5)
  	  (user-position . t)
  	  ))
    (delete-other-windows)
    (split-window-horizontally)
    (setq eik-links-win-w 60)
    (shrink-window-horizontally 32)
    (find-file "~/_wiki/org/organizer-links.org")
    (dedicated-mode)
    (other-window 1)
    (find-file "~/_wiki/org/organizer-daily.org")
    (split-window-vertically)
    (split-window-horizontally)
    (other-window 1)
    (find-file "~/")
    (other-window 1)
    (find-file "~/")
    (other-window 1)
    (other-window 1)
    (dedicated-mode)
    (end-of-buffer)                       ; Go to the end of buffer
    (outline-previous-visible-heading 1)  ; Find the last heading
    (org-cycle)                           ; Make subtree visible
    )
  ```
  Опубликовано: October 9, 2010
** Emacs и Flyspell трики

- Note taken on [2018-02-15 Чтв 10:55] \\
  “Flyspell Позволяет проверять орфографию на часах в Emacs с помощью второстепенного режима. Это называется Flyspell. Этот объект вряд ли навязчив. Это не требует никакой помощи. Flyspell выделяет некорректные слова сразу после их завершения или сразу после.”

  Flyspell можно найти на  [http://www-sop.inria.fr/mimosa/Manuel.Serrano/flyspell/flyspell.html](http://)

  Это также часть Emacs. Смотрите также FlyspellWithoutColors.

  См. FlyspellXmlLang, чтобы переключиться на соответствующий язык, указанный в XML-документе, и посмотрите, как FlyspellBabel переключает язык, как указано в командах LaTeX Babel.

  - Flyspell в других режимах
  - Включить flyspell для комментариев в исходном коде
  - Представления
  - Избегайте ложных срабатываний
  - Изменить словари
  - Успех добавления новых слов в личный словарь
  - Easy Spell Check: привязки клавиш и функция, позволяющая легко использовать FlySpell / ispell / aspell без использования мыши
  - Запустить flyspell с помощью aspell вместо ispell
  - Запустить flyspell-buffer после изменения в словаре
  - Flyspell с subword-mode
  - Flyspell с popup.el
  - Автоматическое отображение текстового всплывающего окна в терминале при использовании обычного меню emacs в графическом интерфейс
  - flyspell в определенном регионе
  - Flyspell в других режимах

  Вот пример, чтобы включить его для текстового режима и отключить его для режима редактирования журнала и режима журнала изменений. Эти два являются производными от текстового режима, и, таким образом, включение режима flyspell-mode для текстового режима также разрешает его для этих двух. Альтернативным решением могло бы быть создание предиката режима летучей мыши, так что символы игнорируются flyspell.

      (dolist (hook '(text-mode-hook))
        (add-hook hook (lambda () (flyspell-mode 1))))
      (dolist (hook '(change-log-mode-hook log-edit-mode-hook))
        (add-hook hook (lambda () (flyspell-mode -1))))
  Используемая выше идиома позволяет легко включать и отключать flyspell для различных основных режимов: просто добавьте соответствующий крючок в список, где уже есть другие крючки.


  - Включить flyspell для комментариев в исходном коде

  Программисты могут использовать flyspell-prog-mode для включения проверки орфографии только в комментариях к исходному коду.

  Flyspell поставляется с режимом проверки комментариев и строк в режимах программирования. Просто введите M-x flyspell-prog-mode или добавьте его в свой режим hooks

  ```
   	 (add-hook 'c++-mode-hook
            (lambda ()
              (flyspell-prog-mode)
              ; ...
            ))
  ```
  - ruediger -

  - Представление

  Я настоятельно рекомендую установить flyspell-issue-message-flag в значение nil, так как печать сообщений для каждого слова (при проверке всего буфера) приводит к огромному замедлению. - nschum

  Избегайте ложных срабатываний

  Недавно я начал использовать flyspell и наслаждаюсь его функциями. Есть ли способ отключить flyspell для определенных регулярных выражений? Например, я хотел бы отключить flyspell при вводе url. В противном случае при вводе URL-адреса, например [http://www.emacswiki.org/cgi-bin/emacs/FlySpell](http://), www, emacswiki, cgi и FlySpell выделяются как ошибки. Любые советы будут приняты с благодарностью. - MattLundin

  Существует только один способ, с помощью предиката flyspell-generic-check-word-predicate, который должен быть функцией. В такой функции вы можете использовать вещь в точке.

  Однако это немного сложно, так как эта переменная может быть только одной функцией. Я отправил исправление Emacs devel, чтобы позаботиться об этом.

  Спасибо, что указали меня на переменную предиката flyspell-generic-check-word-predicate.-MattLundin

  Я заинтересован в рабочем решении игнорировать проверки орфографии URL-адресов и адресов электронной почты. Ответ по адресу[ http://superuser.com/a/345461/40407](http://), по-видимому, имеет отношение к созданию решения с помощью универсального flyspell-generic-check-word-predicat , хотя это не относится к URL-адресам и адресам электронной почты. MattLundin, ты что-нибудь придумал?

  - Изменить словари

  Поскольку мне часто приходится переключаться между английским и немецким языками, я использую эту функцию:


        (defun fd-switch-dictionary()
        (interactive)
        (let* ((dic ispell-current-dictionary)
      	 (change (if (string= dic "deutsch8") "english" "deutsch8")))
          (ispell-change-dictionary change)
          (message "Dictionary switched from %s to %s" dic change)
          ))

        (global-set-key (kbd "<f8>")   'fd-switch-dictionary)

  – FlorianDiesch
  Я тоже чередую разные языки, но не все, что доступно в системе. Я использую следующий код внутри своего .emacs.

      (let ((langs '("american" "francais" "brasileiro")))
        (setq lang-ring (make-ring (length langs)))
        (dolist (elem langs) (ring-insert lang-ring elem)))
      (defun cycle-ispell-languages ()
        (interactive)
        (let ((lang (ring-ref lang-ring -1)))
          (ring-insert lang-ring lang)
          (ispell-change-dictionary lang)))
      (global-set-key [f6] 'cycle-ispell-languages)

  – DiogoRamos
  Как игнорировать или добавлять слово без использования всплывающего меню?
  использование flyspell-auto-correct-word.

  Это не работает для меня. С flyspell-auto-correct-word я могу просмотреть все предложения для исправления, но у меня нет возможности вставить слово в мой словарь.

  - Успшное добавления новых слов в личный словарь

  Я использовал "M x ispell-region", и слова, которые ispell считал неправильными написаниями, были выделены. Точка переместилась к первому т. -исполненному слову. Введя "i", я вставил это слово в свой личный словарь. Позже я обнаружил, что личный словарь хранился в файле $ HOME / .aspell.en.pws в текстовом формате. Несмотря на то, что слово было добавлено, когда я использовал "ispell" вместо "flyspell", но однажды добавив, flyspell также распознал слово как имеющее правильное правописание.Эта информация поступает с веб-страницы: [http://www.delorie.com/gnu/docs/emacs/emacs_109.html.](http://) Спасибо!

  – Namo Amitabha
  Вы также можете ввести "ат", чтобы сделать слово session-local и "Ат" сделать его буфером-local (То есть, чтобы добавить его в список LocalWords.)

  – Bernard Hurley
  Мне нужен способ автоматически вставить слово в пользовательский словарь и добавить его в файл .emacs:

  ```
  	;;; --------------------------------------------------- adding words to flyspell

  	(eval-when-compile (require 'cl))

  	(defun append-aspell-word (new-word)
   	(let ((header "personal_ws-1.1")
         (file-name (substitute-in-file-name "$HOME/.aspell.en.pws"))
         (read-words (lambda (file-name)
                      (let ((all-lines (with-temp-buffer
                                        (insert-file-contents file-name)
                                        (split-string (buffer-string) "\n" t))))
                       (if (null all-lines)
                         ""
                        (split-string (mapconcat 'identity (cdr all-lines) "\n")
                                      nil
                                      t))))))
        (when (file-readable-p file-name)
   	  (let* ((cur-words (eval (list read-words file-name)))
            (all-words (delq header (cons new-word cur-words)))
            (words (delq nil (remove-duplicates all-words :test 'string=))))
      (with-temp-file file-name
       (insert (concat header
                       " en "
                       (number-to-string (length words))
                       "\n"
                       (mapconcat 'identity (sort words #'string<) "\n"))))))
        (unless (file-readable-p file-name)
         (with-temp-file file-name
      (insert (concat header " en 1\n" new-word "\n")))))
       (ispell-kill-ispell t) ; restart ispell
       (flyspell-mode)
       (flyspell-mode))

      (defun append-aspell-current ()
       "Add current word to aspell dictionary"
       (interactive)
       (append-aspell-word (thing-at-point 'word)))
  ```
  – Aaron Michaux

  Легкая проверка орфографии: привязки клавиш и функция, облегчающая использование FlySpell / ispell / aspell без использования мыши. Поместите нижеприведенный код в свой .emacs.


  F8 will call ispell (or aspell, etc) Для слова курсор включен (или рядом). Вы также можете использовать встроенную привязку клавиш M-$.

  Ctrl-Shift-F8 Включает / отключает FlySpell для текущего буфера (выделяет слова с ошибками при вводе)

  Crtl-Meta-F8 Запускает FlySpell в текущем буфере (выделяет все слова с ошибками в буфере)

  Ctrl-F8 Вызовы ispell для выделенного слова FlySpell до позиции курсора

  Meta-F8 Вызовы ispell для выделенного слова FlySpell после позиции курсора

  	;; easy spell check
  	(global-set-key (kbd "<f8>") 'ispell-word)
  	(global-set-key (kbd "C-S-<f8>") 'flyspell-mode)
  	(global-set-key (kbd "C-M-<f8>") 'flyspell-buffer)
  	(global-set-key (kbd "C-<f8>") 'flyspell-check-previous-highlighted-word)
  	(defun flyspell-check-next-highlighted-word ()
  	  "Custom function to spell check next highlighted word"
  	  (interactive)
  	  (flyspell-goto-next-error)
  	  (ispell-word)
  	  )
  	(global-set-key (kbd "M-<f8>") 'flyspell-check-next-highlighted-word)

  Как я могу разместить подсказки flyspell в окне, которое находится ниже текущего окна? В настоящее время, на Aquamacs, запуская цветную тему leuven, когда появляются предложения, вкладки не исчезают (они это делали, когда я не использовал цветовую тему). Тема действительно хороша (в сочетании с org-mode), поэтому я не хочу избавляться от этого. Как я могу заставить окно предложения появиться чуть выше modeline?

  - Запуск Flyspell с Aspell вместо Ispell

  Если вы используете flyspell с aspell вместо ispell, вам нужно добавить:

  	(setq ispell-list-command "--list")
  Поскольку опция "-1" означает "--lang" в аспелле, а опция "-1" означает "--list" в ispell. Эта проблема связана с буфером flyspell и областью flyspell.


  - Запуск Flyspell буфера после переключения два словаря

  Если я добавлю слово во время сессии flyspell, оно все еще будет помечено как ошибочное. И слово «flyspell-correct-previous-word» говорит мне, что это правильное написание. Как запускать flyspell-buffer в буфере каждый раз, когда словарь модифицируется?

  -kd

  - Flyspell with subword-mode

  Когда включен subword-mode, особенно в cc-mode, слова выделяются более умело, например, "GoodBadType", → , "Good","Bad" и "Type". Как установить flyspell для работы в этом контексте?

  -Kiwon

  - Flyspell with popup.el

  Если вы предпочитаете использовать меню Flyspell в терминале или просто предпочитаете использовать popup.el в графическом меню, вставьте его где-нибудь в своем пути загрузки:

      (defun flyspell-emacs-popup-textual (event poss word)
        "A textual flyspell popup menu."
        (require 'popup)
        (let* ((corrects (if flyspell-sort-corrections
                             (sort (car (cdr (cdr poss))) 'string<)
                           (car (cdr (cdr poss)))))
               (cor-menu (if (consp corrects)
                             (mapcar (lambda (correct)
                                       (list correct correct))
                                     corrects)
                           '()))
               (affix (car (cdr (cdr (cdr poss)))))
               show-affix-info
               (base-menu  (let ((save (if (and (consp affix) show-affix-info)
                                           (list
                                            (list (concat "Save affix: " (car affix))
                                                  'save)
                                            '("Accept (session)" session)
                                            '("Accept (buffer)" buffer))
                                         '(("Save word" save)
                                           ("Accept (session)" session)
                                           ("Accept (buffer)" buffer)))))
                             (if (consp cor-menu)
                                 (append cor-menu (cons "" save))
                               save)))
               (menu (mapcar
                      (lambda (arg) (if (consp arg) (car arg) arg))
                      base-menu)))
          (cadr (assoc (popup-menu* menu :scroll-bar t) base-menu))))
  И поместите это в ваш файл инициализации:

      (eval-after-load "flyspell"
        '(progn
           (fset 'flyspell-emacs-popup 'flyspell-emacs-popup-textual)))
  Теперь при вызове тэга "flyspell-correct-word-before-point" или щелчка по среднему слову создаст текстовое всплывающее окно.

  - Автоматическое отображение текстового всплывающего окна в терминале при использовании обычного меню emacs в графическом интерфейсе

  Если вы запускаете Emacs-сервер с терминалами и GUI-клиентами, вы можете выбрать тип меню, который будет выбираться автоматически в зависимости от того, какой клиент вы используете. Вместо того, чтобы переопределять flyspell-emacs-popup, лучше посоветовать это, чтобы при необходимости можно было назвать flyspell-emacs-popup-textual (определено выше) или исходную функцию


  Сначала небольшая вспомогательная функция для использования в качестве рекомендации:

  	  (defun flyspell-emacs-popup-choose (org-fun event poss word)
  	(if (window-system)
  	    (funcall org-fun event poss word)
  	  (flyspell-emacs-popup-textual event poss word)))
  Теперь поместите это в ваш файл инициализации:

      (eval-after-load "flyspell"
        '(progn
            (advice-add 'flyspell-emacs-popup :around #'flyspell-emacs-popup-choose)))
  Примечание. Я использовал новый синтаксис для консультаций. Если у вас нет последних emacs, вам может понадобиться изменить это на старый синтаксис. Бернард Херли


  - Пропустить Flyspell один конкретный регион

  Это полезно для кода в файлах org, но любой регион с четкими разделителями можно пропустить
  ```
    (add-to-list 'ispell-skip-region-alist '("^#+BEGIN_SRC" . "^#+END_SRC"))
  ```
  - chedi -

  CategoryModes | CategorySpelling ==



  Tags:
    emacs
** Полезности и трюки

- Note taken on [2018-02-15 Чтв 10:56] \\

    1) начну с элементарного. интерфейс. я не пользуюсь кнопками, меню, скролл баром, т.к. считаю их не эффективными и безполезными. убираем их.




  ```
      ;; scroll bar
  (scroll-bar-mode -1)

  ;; tool bar
  (tool-bar-mode -1)

  ;; menu bar
  (menu-bar-mode -1)
  ```

  2) мне не нравятся цвета, что идут по умолчанию. решил заменить их на более темные и приятные глазу (у меня LCD).
  ```
  (set-background-color "#333333")
  (set-foreground-color "#ffffff")
  ```
  если они вас не устраивают, вы можете посмотреть список всех цветов 'M-x list-color-display' и изменить на понравившийся. цвет курсора — (set-cursor-color <цвет>)

  3) шрифты. вот тут можно спорить бесконечно. как многим известно в emacs с относительно недавних пор появилась поддержка xft. кому-то оно может и нравится, но для программирования я больше предпочитаю bitmap шрифты. единственный минус — это utf8, далеко не все держат его. по этой причине я выбрал terminus. и 0 от о в нем отличишь, а это важный момент. я меняю шрифты через .Xdefaults. в windows это делается через реестр, гугл поможет.

  Emacs.font: -*-terminus-medium-*-*-*-16-*-*-*-*-*-*-*


  4) utf8. для правильного отображения utf8 в shell и dired.

  ```
  (setq file-name-coding-system 'utf-8)
  ```


  ГОРЯЧИЕ КЛАВИШИ И ПОЛЕЗНЫЕ МЕЛОЧИ

  5) поменяйте capslock на ctrl. очень важная вещь. это, думаю, самое главное для эффективного использования emacs. насчет этого тоже возникает множество споров, но мне кажется это довольно удобным. добавьте в .xmodmaprc (если его нет у вас, создайте) следущее:

  keycode 66 = Control_L
  clear Lock
  add Control = Control_L


  добавьте строку в .xinitrc или .xsession, в зависимости от того как вы грузите иксы.

  xmodmap .xmodmaprc


  6) удобный скроллинг и выделение текущей строки. по умолчанию emacs прокручивает почти на половину экрана, что крайне не удобно. исправим это. и еще бывает что теряешь место курсора, для этого включаем подсветку текущей строки.
  ```
  (setq scroll-step 1)
  (global-hl-line-mode 1)
  ```

  7) мы знаем, 'C-x o' переключает фокус на следущее окно. а если окон 5 или 10? делаем навигацию проще.

  (windmove-default-keybindings 'meta)


  теперь навигация будет проходить следущим образом: alt + \arrow keys\.

  8) изменять размеры окна, по умолчанию, можно мышкой… для этого нужно убирать руку от клавиатуры. а это удобно? я тоже так думаю. добавлем следущее в .emacs.
  ```
  (defun win-resize-top-or-bot ()
  "Figure out if the current window is on top, bottom or in the
  middle"
  (let* ((win-edges (window-edges))
  (this-window-y-min (nth 1 win-edges))
  (this-window-y-max (nth 3 win-edges))
  (fr-height (frame-height)))
  (cond
  ((eq 0 this-window-y-min) "top")
  ((eq (- fr-height 1) this-window-y-max) "bot")
  (t "mid"))))

  (defun win-resize-left-or-right ()
  "Figure out if the current window is to the left, right or in the
  middle"
  (let* ((win-edges (window-edges))
  (this-window-x-min (nth 0 win-edges))
  (this-window-x-max (nth 2 win-edges))
  (fr-width (frame-width)))
  (cond
  ((eq 0 this-window-x-min) "left")
  ((eq (+ fr-width 4) this-window-x-max) "right")
  (t "mid"))))

  (defun win-resize-enlarge-horiz ()
  (interactive)
  (cond
  ((equal "top" (win-resize-top-or-bot)) (enlarge-window -1))
  ((equal "bot" (win-resize-top-or-bot)) (enlarge-window 1))
  ((equal "mid" (win-resize-top-or-bot)) (enlarge-window -1))
  (t (message "nil"))))

  (defun win-resize-minimize-horiz ()
  (interactive)
  (cond
  ((equal "top" (win-resize-top-or-bot)) (enlarge-window 1))
  ((equal "bot" (win-resize-top-or-bot)) (enlarge-window -1))
  ((equal "mid" (win-resize-top-or-bot)) (enlarge-window 1))
  (t (message "nil"))))

  (defun win-resize-enlarge-vert ()
  (interactive)
  (cond
  ((equal "left" (win-resize-left-or-right)) (enlarge-window-horizontally -1))
  ((equal "right" (win-resize-left-or-right)) (enlarge-window-horizontally 1))
  ((equal "mid" (win-resize-left-or-right)) (enlarge-window-horizontally -1))))

  (defun win-resize-minimize-vert ()
  (interactive)
  (cond
  ((equal "left" (win-resize-left-or-right)) (enlarge-window-horizontally 1))
  ((equal "right" (win-resize-left-or-right)) (enlarge-window-horizontally -1))
  ((equal "mid" (win-resize-left-or-right)) (enlarge-window-horizontally 1))))

  (global-set-key [C-M-down] 'win-resize-mi2nimize-vert)
  (global-set-key [C-M-up] 'win-resize-enlarge-vert)
  (global-set-key [C-M-left] 'win-resize-minimize-horiz)
  (global-set-key [C-M-right] 'win-resize-enlarge-horiz)
  (global-set-key [C-M-up] 'win-resize-enlarge-horiz)
  (global-set-key [C-M-down] 'win-resize-minimize-horiz)
  (global-set-key [C-M-left] 'win-resize-enlarge-vert)
  (global-set-key [C-M-right] 'win-resize-minimize-vert)

  ```
  как видно из keymap' ом, 'ctrl + alt + \arrow keys\' резайзит окна.

  9) думаю, не только меня раздражает, то что надо всегда набирать yes или no, когда закрываешь буффер или покидаешь emacs. не легче набрать y или n?
  ```
  (fset 'yes-or-no-p 'y-or-n-p)
  ```

  это сэкономит от одного, до двух лишних нажатий.

  10) при работе с большим количеством буферов, я испытывал неудобство при переключении между ними, я долго не мог найти то что мне нужно. оказывается у emacs'а был режим и для этого.
  ```
  (iswitchb-mode 1)
  ```

  кстати это старый вариант переключения между буфферами. не пойму зачем его убрали. теперь по нажатию 'C-x b' будет вызыватся iswitchb-buffer. он автоматически отбрасывает не нужное, а когда остается единственный вариант, то достаточно нажать tab и вы переключитесб на нужный буфер. единственный минус который я заметил — если есть буферы с названиями: in и main, то введя in он выбирает main, а обратиться к in бывает невозможно. может и есть на это клавиша или команда, но я не нашел.

  и еще я решил добавить более удобные клавиши для переключения на следущий/предыдущий буфер.
  ```
  (global-set-key [?\C-,] 'previous-buffer)
  (global-set-key [?\C-.] 'next-buffer)
  ```

  11) бывают моменты когда забываешь зажать ctrl для навигации через 'C-n' 'C-p' и т.д. и получаются не нужные последовательности типа: nnnnnnnnnnnn ppppppppppp ffffffff. не удалять же все backspace' ом… можно сделать горячюю клавишу для bacward-kill-word.
  ```
  (global-set-key "\C-w" 'backward-kill-word)
  (global-set-key "\C-x\C-k" 'kill-region)
  (global-set-key "\C-c\C-k" 'kill-region)
  ```

  теперь чтобы «убить» выделенный текст придется нажимать 'C-x C-k', т.к. на 'C-w' мы назначили bacward-kill-region.

  12) макросы — мощная вещь как в программировании, так и в emacs. они достойны того чтобы выделить им удобные кейбиндинги.
  ```
  (global-set-key [f2] 'kmacro-call-macro)
  (global-set-key [f3] 'kmacro-start-macro-or-insert-counter)
  (global-set-key [f4] 'kmacro-end-or-call-macro)
  ```

  - f2 — call macro
  - f3 — start macro
  - f4 — end macro

  13) часто бывает, когда надо переключится на начало буффера, а потом обратно на место, где был ранее. для этого есть закладки. для удобства я добавил горячие клавиши для их вызова.
  ```
  (global-set-key [f5] 'bookmark-set)
  (global-set-key [f6] 'bookmark-jump)
  ```

  f5, вводите имя закладки, делайте что нужно, f6, вводите имя закладки, и вы опять на том же месте.

  14) используйте воркспейсы. это дает много новых возможностей. например, вы сможете читать почту с помощью gnus на первом воркспейсе, отлаживать программу на втором, редактировать код на третьем, а на пятом шелл. чертовски удобно, неправда ли?

  вот ссылка на workspaces.el.

  скопируйте его в свою загрузочную директорию. если у вас ее нет. то создайте директорию elisp (или как вам удобно) в домашнем каталоге (или как вам удобно) и добавьте в .emacs:
  ```
  (add-to-list 'load-path "~/elisp") ;; если уже подгрузили, то естественно это уже писать не надо
  (require 'workspaces)
  (global-set-key [?\C-q] 'workspace-goto)
  ```

  я решил выбрать 'C-q'. 'C-q' \0-9\ — переключает на нужный воркспейс. как вы уже, наверное, поняли максимальное их количество- 9.

  15) если вы работаете с большим количеством файлов/буферов и решили закрыть emacs, а потом решили возобновить работу. не открывать же их заново… попросим emacs сохранять сессию перед выходом.
  ```
  (desktop-save-mode t)
  ```


  Tags:
    emacs
** Проверка орфографии


- Note taken on [2018-02-15 Чтв 10:58] \\
  Итак, для начала выберем программу для проверки орфографии. Их довольно много, одной из самых хороших считается hunspell. Её используют OpenOffice, LibreOffice, Firefox и другие. К сожалению для выбранного мной плагина она работает немного не так, как нужно, поэтому я остановился на форке Hunspell - enchant, результаты, насколько я могу судить, она выдаёт такие же как и её родитель, отличия только в API. Словари для неё подходят те же, что и для Hunspell, тут я не специалист, выбрал те, что нашёл у себя в репозитории: русский и английский. Если постараться можно отыскать десятки других, в том числе например те, которые не считают использование "е" вместо "ё" ошибкой. Для archlinux поставить это можно вот так:
  `yaourt -S enchant hunspell-en hunspell-ru-aot`
  Что бы было понимание как все это работает, я покажу как использовать enchant из command line. Нам понадобятся 2 режима. В первом на вход будем подавать строку с текстом, который хотим проверить, а в ответ получим список слов, которые являются ошибочными:
  `$ echo "Привед, как у тибя дела? Helllo all right" | enchant -d ru_RU -l`
  >Привед
  тибя
  Helllo
  all
  right

  Как ожидалось, русский словарь ничего про английский не знает, поэтому все английские слова пометил как ошибочные. Но мне то требуется двуязычная поддержка. Для решения этой проблемы предлагаются разные варианты, некоторые предлагают сливать 2 словаря в один, другие - вычленять из текста сначала русские слова и прогонять через русский словарь, потом английские - через английский. Оба варианта мне не нравятся, поэтому я просто написал скрипт, который результаты работы русского словаря прогоняет через английский, назвал его spell_check_text.sh, сделал его исполняемым и положил рядом с конфигом emacs:

  	!/bin/bash
  	enchant -d ru_RU -l | enchant -d en_US -l

  Протестируем работу:

  `$ echo "Привед, как у тибя дела? Helllo all right" | ./spell_check_text.sh`
  >Привед
  тибя
  Helllo

  Вуаля, теперь результаты правильные. Второй режим работы enchant о котором я говорил - позволяет получить варианты правильного написания слова по неправильному:

  `$ echo "Привед" | enchant -d ru_RU -a`

  >@(#) International Ispell Version 3.1.20 (but really Enchant 1.6.0)
  & Привед 9 0: Приведи, Приведу, Приведя, Привод, Привад, Привес, Присед, Привет, Привей

  Но поскольку нам опять же нужна проверка двух языков сразу я опять написал скрипт spell_check_word.sh и положил его рядом с spell_check_text.sh:

  	#!/bin/sh
  	read word;
  	echo $word |
  	if [[ $word =~ [a-zA-Z] ]]
  	then
   	enchant -d en_US -a
  	else
   	enchant -d ru_RU -a
  	fi

  Смысл думаю очевиден - если находим хоть один английский символ в слове - прогоняем его через английский словарь, иначе через русский.

  Осталось прикрутить это все к emacs. Встроенные плагины показались мне очень медленными и мало настраиваемыми, хотя не исключаю, что я просто не умею их готовить. Поэтому я остановился на wcheck-mode, который позволяет настроить почти все что нужно, причём сделать это довольно просто. Плюс у него есть несколько оптимизаций по скорости работы - проверка выполняется в отдельном процессе, только для видимой части текста, только во время простоя, ну и ещё там несколько оптимизаций для увеличения скорости. Научим wcheck-mode правильно работать с enchant:

  	(defvar lcl-var:spelling-ignore nil)

  	(defun lcl:spelling-add-to-dictionary (marked-text)
    	(let* ((word (downcase (aref marked-text 0)))
  	         (dict (if (string-match "[a-zA-Z]" word)
                   (message "en_US.dic")
                   (message "ru_RU.dic")))
           (file (concat "~/.config/enchant/" dict)))
      (when (and file (file-writable-p file))
        (with-temp-buffer
          (insert word) (newline)
          (append-to-file (point-min) (point-max) file)
          (message "Added word \"%s\" to the \"%s\" dictionary" word dict))
        (wcheck-mode 0)
        (wcheck-mode 1))))

  	(defun lcl:spelling-add-to-ignore (marked-text)
  	  (let ((word (aref marked-text 0)))
      (add-to-list 'lcl-var:spelling-ignore word)
      (message "Added word \"%s\" to the ignore list" word)
      (wcheck--hook-outline-view-change)))

  	(defun lcl:spelling-action-menu (marked-text)
  	  (append (wcheck-parser-ispell-suggestions)
            (list (cons "[Add to dictionary]" 'lcl:spelling-add-to-dictionary)
                  (cons "[Ignore]" 'lcl:spelling-add-to-ignore))))

  	(defun lcl:delete-list (delete-list list)
  	  (dolist (el delete-list)
      (setq list (remove el list)))
   	 list)

  	(defun lcl:spelling-parser-lines (&rest ignored)
   	 (lcl:delete-list lcl-var:spelling-ignore
                     (delete-dups
                      (split-string
                       (buffer-substring-no-properties (point-min) (point-max))
                       "\n+" t))))

  	(defun cfg:spelling ()
   	 (require 'wcheck-mode)
   	 (defun wcheck--choose-action-minibuffer (actions)
      (cdr
       (assoc
        (ido-completing-read "Choose " (mapcar #'car actions))
        actions)))
  	  (setq-default
  	   wcheck-language "All"
  	   wcheck-language-data
  	   '(("All"
        (program . "~/.config/emacs/bin/spell_check_text.sh")
        (parser . lcl:spelling-parser-lines)
        (action-program . "~/.config/emacs/bin/spell_check_word.sh")
        (action-parser . lcl:spelling-action-menu)
        (read-or-skip-faces
         ((emacs-lisp-mode c-mode c++-mode python-mode)
          read font-lock-comment-face)
         (org-mode
          skip org-block-begin-line org-block-end-line org-meta-line org-link)
         (nil))
        ))))
  	(cfg:spelling)

  Выглядит немного сложно, но я постараюсь объяснить что тут происходит. Вся настройка выполняется в функции "cfg:spelling", в ней, во-первых, переопределяется функция "wcheck–choose-action-minibuffer" из плагина, что бы список вариантов исправления выдавался через ido, можно конечно этого не делать и оставить оригинальную реализацию, но мне она не нравится. Дальше заполняется переменная "wcheck-language-data":
  program
  Какой script будем вызывать для нахождения всех ошибочных слов в тексте, тут я указал путь к описанному ранее spell_check_text.sh
  parser
  Это функция которая распарсит результаты работы скрипта из "program". Реализация lcl:spelling-parser-lines довольно очевидна, обращу лишь внимание на то, что я из результатов удаляю слова добавленные в "ignore" (про эту опция напишу ниже)
  action-program
  Тут указываем какой скрипт вызывать для того, что бы показать варианты правильного написания для слова для слова. Скрипт spell_check_word.sh - я тоже описывал ранее.
  action-parser
  Соответственно parser результатов вызова "action-program". Тут стоит обратить внимание, что помимо результатов я добавил вывод пунктов меню "Add to dictionary" и "Ignore". Если выбрать первый, то слово добавится в пользовательский русский или английский словарь enchant, которых находится тут: "~/.config/enchant/". Само добавление написано в "lcl:spelling-add-to-dictionary", принадлежность слова к определённому языку, опять же определяется по тому есть в нем английские символы или нет. А добавление слова в "Ignore" означает, что в текущей сессии работы с Emacs это слово не будет проверяться во всех буферах. Добавление происходит в "lcl:spelling-add-to-ignore" и фактически сводится к добавлению в переменную "lcl-var:spelling-ignore".
  read-or-skip-faces
  Интересная опция, в данной реализации она говорит, что в режимах "emacs-lisp-mode c-mode c++-mode python-mode" нужно проверять только тот текст, который имеет face "font-lock-comment-face", т.е. только в комментариях. А в режиме "org-mode" проверять весь текст кроме того, который имеет face один из: "org-block-begin-line org-block-end-line org-meta-line org-link", т.е. убираем проверку в служебных тегах и т.п. Если нужно, то вот функция которая поможет узнать текущий face под курсором:

  	(defun cfg:what-face (pos)
  	  (interactive "d")
  	  (let ((face (or (get-char-property (point) 'read-face-name)
                    (get-char-property (point) 'face))))
      (if face (message "Face: %s" face) (message "No face at %d" pos))))

  Теперь осталось только по желанию навесить горячие клавиши на управление всем этим хозяйством:
  wcheck-mode - функция включения\выключения режима проверки орфографии
  wcheck-actions - показать варианты исправления для слова под курсором
  wcheck-jump-forward - перейти к следующей ошибке
  wcheck-jump-backward - перейти к предыдущей ошибке
  В работе выглядит проверка вот так:


  Получилось слегка затянуто, но я постарался подробно описать что и откуда берётся, что бы можно было при необходимости доработать под себя.
** Примеры emacs
[[~/Dropbox/orgs/README.org][Хорошо настроенный emacs]]
** Emacs, Aspell и одновременное использование словарей

- Note taken on [2018-02-15 Чтв 10:52] \\
  .
  Недавно задался вопросом как осуществлять проверку правописания для буфера, в котором есть как русские, так и английские слова.
  На ЛОРе подсказали решение, которое показалось мне вполне приемлемым. Привожу его в том виде, в котором оно осталось в моем .emacs (т.е. почти без изменений):
  ```
  ;;=============================================================================
  ;;
  ;;Настройка проверки правописания Ispell
  ;;
  (require 'flyspell)
  (require 'ispell)

  (setq
  ; i like aspel, and you?
   ispell-program-name "aspell"

  ; my dictionary-alist, using for redefinition russian dictionary
   ispell-dictionary-alist
  '(("english"                       ; English
      "[a-zA-Z]"
   "[^a-zA-Z]"
   "[']"
   nil
   ("-d" "en")
   nil iso-8859-1)
  ("russian"                       ; Russian
      "[АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЫЪЭЮЯабвгдеёжзийклмнопрстуфхцчшщьыъэюя]"
   "[^АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЫЪЭЮЯабвгдеёжзийклмнопрстуфхцчшщьыъэюя]"
   "[-]"
   nil
   ("-C" "-d" "ru")
   nil utf-8)
  (nil                             ; Default
      "[A-Za-z]"
   "[^A-Za-z]"
   "[']"
   nil
   ("-C")
   nil iso-8859-1))

  ispell-russian-dictionary "russian"
  ispell-english-dictionary "english"
  flyspell-default-dictionary ispell-russian-dictionary
  ispell-dictionary ispell-english-dictionary
  ispell-local-dictionary ispell-russian-dictionary
  ispell-extra-args '("--sug-mode=ultra"))

  (defun flyspell-russian ()
  (interactive)
  (flyspell-mode t)
  (ispell-change-dictionary ispell-russian-dictionary)
  (flyspell-buffer)
  (message "Russian dictionary - Spell Checking completed."))

  ; English
  (defun flyspell-english ()
  (interactive)
  (flyspell-mode t)
  (ispell-change-dictionary ispell-english-dictionary)
  (flyspell-buffer)
  (message "English dictionary - Spell Checking completed."))

  (setq ispell-highlight-face (quote flyspell-incorrect))
  (setq ispell-have-new-look t)
  (setq ispell-enable-tex-parser t)
  (add-hook 'text-mode-hook 'flyspell-mode)
  (setq flyspell-delay 1)
  (setq flyspell-always-use-popup t)

  (global-set-key [f1] 'ispell-word)
  (global-set-key [f7] 'ispell-buffer); проверить орфографию в текущем буфере
  (global-set-key [f8] 'ispell-region)
  (global-set-key [f9] 'auto-fill-mode); вкл/выкл автозаполнения
  (global-set-key [f10] 'flyspell-english)
  (global-set-key [f11] 'flyspell-russian)
  (global-set-key [f12] 'flyspell-mode); вкл/выкл проверки орфографии "на ходу"
  ;;
  ;;============================================================================

  ```

  Tags:
    emacs
** Работаем с почтой через Emacs и Wanderlust


- Note taken on [2018-02-15 Чтв 11:01] \\
  Работаем с почтой через Emacs и Wanderlust
  Emacs
      Давайте сегодня попробуем настроить почтовый клиент Wanderlust для emacs и освоим азы его использования. Руководство будет максимально простым — настройка одной учетной записи Gmail, но с учетом всех основных нюансов. Если у вас не получилось с Gnus — то вам все-таки стоит попробовать этот клиент, он гораздо проще в настройке и работе.

  Желательно, чтобы ваша ОС была Linux или *BSD. В противном случае могут возникнуть проблемы с настройкой SSL, который требует Gmail.
  Установка Wanderlust
      К сожалению, автор Wanderlust не потрудился создать elpa пакет, так что поставить клиент через стандартный пакетный менеджер emacs не получится. В репозитариях вашего дистрибутива пакет называется wl или wl-beta. Последний вариант предпочтительнее. Еще вам понадобится пакет gnutls-bin. Так что в случае debian или ubuntu:

    aptitude install gnutls-bin semi apel flim
    aptitude install wl-beta


      Теперь нужно добавить Wanderlust в автозагрузку emacs, делается это путем добавления в конец вашего .emacs строчки:

  (autoload 'wl  "Wanderlust" )

  Настраиваем учетную запись
      Если вы — матерый пользователь emacs, то сами определите куда положить настройки учетной записи, если не хотите об этом думать, то просто допишите в конец вашего файла .emacs следующий код(можно не вникать — просто замените те 3 строчки, что отвечают за вашу учетную запись):

  ;; эта часть настроек для доступа к Gmail по IMAP
  ( elmo-imap4-default-server "imap.gmail.com"
        elmo-imap4-default-user "ваш_адрес@gmail.com"
        elmo-imap4-default-authenticate-type 'clear
        elmo-imap4-default-port '
        elmo-imap4-default-stream-type 'ssl
        elmo-imap4-use-modified-utf7 )

  ;; тут настройки отвечающие за SMTP
  ( wl-smtp-connection-type 'starttls
        wl-smtp-posting-port
        wl-smtp-authenticate-type "plain"
        wl-smtp-posting-user "ваш_адрес_без_@gmail.com_на_конце"
        wl-smtp-posting-server "smtp.gmail.com"
        wl-local-domain "gmail.com"
        wl-message-id-domain "smtp.gmail.com")

  ( wl-from "Имя которое получатели ваших писем увидят в поле From <ваш_адрес@gmail.com>"

      ;; настройки папок IMAP
      ;; если у вас в настройках gmail стоит русский язык то копируйте все как есть
      ;; gmail создает имена папок в зависимости от локали
      wl-default-folder "%inbox"
      wl-draft-folder   "%[Gmail]/Черновики"
      wl-trash-folder   "%[Gmail]/Корзина"
      wl-fcc            "%[Gmail]/Отправленные"

      wl-fcc-force-as-read
      wl-default-spec )



  Теперь перезапустите emacs и наберите M-x wl. После перезапуска Wanderlust затребует пароль от IMAP, а также покажет краткую справку о себе, которую можно закрыть как и всякий буфер.
  Первый запуск
  Не пугайтесь, но первым делом вы увидите нечто непримечательное вроде:
  Для того, чтобы увидеть вашу почту нажмите «g». Wanderlust предложит вам выбрать папку, письма из которой вы хотите просмотреть. В данном случае достаточно будет просто нажать Enter для выбора папки %inbox. Если вы правильно ввели пароль то должны увидеть список писем.
  Чтобы быстро скрыть/показать окно просмотра сообщения нажмите «v». Для фильтрации сообщений по любому полю нажмите "?".
  Создание сообщений

      Чтобы ответить на письмо, выберите его курсором и нажмите a(или A, если хотите ответить с полным цитированием).
      чтобы написать новое письмо нажмите w
      Чтобы прикрепить файл к редактируемому письму нажмите C-c C-x TAB
      для отправки готового сообщения нажмите C-c C-c

  Операции над сообщениями

      Сортировка выполняется при помощи функции wl-summary-sort — список возможных полей для сортировки можно увидеть нажав TAB.
      Удаление сообщения выполняется при помощи нажатия d напротив него, а затем — x
      Вы можете выделить строки с сообщениями, которые хотите удалить. Для удаления нажмите m D x
      Для сохранения сообщения в файл, чтобы просмотреть его в другом клиенте, нажмите e. Таким же образом сохраняются вложения из писем — только нужно открыть письмо и перейти на место где расположен прикрепленный файл и там уже нажать e
      Для копирования сообщения в другую папку нажмите O

  Заключение
      В статье рассмотрен необходимый минимум для работы с почтой(во всяком случае для рядового пользователя) в emacs с использованием Wanderlust. К сожалению пока рассмотрена только работа с одним аккаунтом. Когда у меня получится сделать конфигурацию, которая бы сочетала работу как с IMAP так и с POP3 аккаунтами, тогда возможно выйдет следующая статья.
** Справочник команд GNU Emacs

- Note taken on [2018-02-15 Чтв 11:02] \\
  ## **Справочник команд GNU Emacs**
  >(для версии 25)

  1.Emacs  Для запуска GNU Emacs 25, просто наберите имя программы:  emacs
  2.Приостановить работу Emacs (или свернуть в иконку при работе в X)   C-z
  Выйти из Emacs C-x C-c

  3.Файлы

  открыть файл в Emacs C-x C-f
  сохранить файл обратно на диск C-x C-s
  сохранить все файлы  C-x s
  вставить содержимое другого файла в текущий буфер  C-x i
  открыть нужный вам файл вместо текущего  C-x C-v
  сохранить буфер в указанном файле  C-x C-w
  Переключить состояние буфера “только для чтения” C-x C-q

  4.Получение помощи

  Справочная система достаточно проста. Hажмите C-h (или F1)
  и следуйте инструкциям. Если вы в первый
  раз работаете с Emacs, то наберите C-u C-h t Russian RET
  для вызова
  учебника.
  Скрыть окно справки  C-x 1
  Прокрутить окно справки  C-M-v
  apropos: показать команды, соответствующие строке  C-h a
  показать имя функции, которая запускается клавишей  C-h k
  получить информацию о функции  C-h f
  получить информацию о режиме  C-h m

  5.Исправление ошибок

  прервать частично набранную или исполняемую команду  C-g
  восстановить файл, потерянный при крахе системы  M-x recover-file
  отменить нежелательные изменения  C-x u, C-_ или C-/
  восстановить буфер в первоначальное состояние  M-x revert-buffer
  перерисовать заполненный мусором экран C-l 6

  6. Наращиваемый поиск

  поиск вперед C-s
  поиск назад C-r
  поиск по регулярному выражению вперед C-M-s
  поиск по регулярному выражению назад C-M-r
  выбрать предыдущую строку поиска M-p
  выбрать следующую строку поиска M-n
  прекратить наращиваемый поиск RET
  отменить эффект ввода последнего символа  DEL
  прервать текущий поиск  C-g
  Для повтора поиска в любом направлении используйте клавиши  C-s
  или  C-r
  . Если Emacs все еще производит поиск, C-g
  отменит только не выполненную часть

  7.Перемещение

  единицы перемещения     назад    вперед
  символ                                C-b             C-f
  слово                                  M-b             M-f
  строка                                 C-p             C-n
  начало (или конец) строкиC-a             C-e
  предложение                     M-a             M-e
  абзац                                   M-{             M-}
  страница                            C-x [           C-x ]
  выражение (sexp)             C-M-b           C-M-f
  функция                             C-M-a           C-M-e
  переход в начало (или конец) буфера M-<             M->
  прокрутка экрана вниз  C-v
  прокрутка экрана вверх  M-v
  прокрутка влево  C-x <
  прокрутка вправо  C-x >
  установка текущей строки в центр экрана  C-u C-l

  8.Уничтожение и удаление

  уничтожаемый объект                                       назад            вперед
  символ (удаление, а не уничтожение) 		DEL             C-d
  слово								M-DEL           M-d
  строка (до конца строки)					M-0 C-k         C-k
  предложение							C-x DEL         M-k
  выражение							M– C-M-k        C-M-k
  уничтожить	область					C-w
  скопировать область в список уничтожений	M-w
  уничтожить до следующего вхождения символа char M-z char
  вставить последний уничтоженный объект       C-y
  заменить только что восстановленный текст предшествующим уничтоженным текстом
  M-y

  9.Пометка

  установить пометки C-@ или C-SPC
  поменять местами курсор и пометку C-x C-x
  пометить arg слов M-@
  пометить параграф M-h
  пометить страницу C-x C-p
  пометить выражение C-M-@
  пометить функцию C-M-h
  пометить весьбуфер C-x h

  10.Замена с запросом

  интерактивная замена текстовой строки M-%
  с использованием регулярных выражений M-x query-replace-regexp

  В режиме интерактивной замены пользователю доступны следующие команды:
  заменить данное соответствие, перейти к следующему SPC
  заменить это соответствие, не перемещаться ,
  пропустить соответствие без замены DEL
  заменить все оставшиеся соответствия !
  вернуться к предыдущему соответствию ˆ
  выйти из режима “замена с запросом” RET
  войти в режим рекурсивного редактирования (для выхода используется C-M-c)

  11.Использование нескольких окон

  Команды, приведенные во втором столбце, применяются к другому фрэйму (окну используемой оконной системы).

  удалить все остальные окна C-x
  разбить окно по горизонтали C-x 2           C-x 5 2
  удалить данное окно C-x 0           C-x 5 0
  разбить окно по вертикали C-x 3
  выполнить прокрутку в другом окне C-M-v
  переместить курсор в другое окно C-x o           C-x 5 o
  выбрать буфер в другом окне C-x 4 b         C-x 5 b
  показать буфер в другом окне C-x 4 C-o       C-x 5 C-o
  загрузить файл в другое окно C-x 4 f         C-x 5 f
  открыть файл в режиме чтения в другом окне C-x 4 r         C-x 5 r
  запустить Dired в другом окне C-x 4 d         C-x 5 d
  найти таг в другом окне C-x 4 .         C-x 5 .
  увеличить высоту окна C-x ˆ
  сузить текущее окно C-x {
  расширить текущее окноC-x }

  12.Форматирование

  сделать отступ для текущей строки (в зависимости от режима) TAB
  сделать отступ для области (в зависимости от режима) C-M-\
  сделать отступ для выражения (в зависимости от режима) C-M-q
  сделать отступ к заданной arg колонке C-x TAB
  вставить новую строку после курсора C-o
  сдвинуть остаток строки вертикально вниз C-M-o
  удалить пустые строки вокруг курсора C-x C-o
  объединить строку с предыдущей (со следующими arg) M-ˆ
  удалить пустое пространство вокруг курсора M-\
  поместить только один пробел в позиции курсора M-SPC
  отформатировать текущий параграф M-q
  установить столбец заполнения C-x f
  установить префикс заполнения каждой строки C-x .
  установить начертание (face) M-g

  13.Изменение регистра

  сделать буквы слова заглавными M-u
  сделать буквы слова строчными M-l
  сделать первую букву слова заглавной M-c
  сделать буквы области заглавными C-x C-u
  сделать буквы области строчными C-x C-l

  14.Минибуфер

  Следующие клавиши (ключи) определены в минибуфере.

  дополнить насколько возможно TAB
  дополнить до одного слова SPC
  дополнить и выполнить RET
  показать возможные дополнения ?
  выбрать предыдущую строку из истории ввода M-p
  выбрать следующую строку из истории ввода M-n
  поиск в истории по регулярному выражению в обратном напрвлении M-r
  поиск в истории по регулярному выражению в прямом напрвлении M-s
  прервать команду C-g

  Наберите C-x ESC ESC для редактирования и повторения последней команды набранной в минибуфере.
  Наберите F10 , чтобы работать с пунктами меню при помощи команд минибуфера.

  15.Буфера

  выбрать другой буфер C-x b
  выдать список всех буферов C-x C-b
  уничтожить буфер C-x k

  16.Перестановка данных

  обменять местами символы C-t
  обменять местами словаM-t
  обменять местами строки C-x C-t
  обменять местами выражения C-M-t

  17.Проверка правописания

  проверить текущее слово M-$
  проверить все слова в области M-x ispell-region
  выполнить проверку всего буфера M-x ispell-buffer

  18.Теги

  найти определение тега M-.
  найти следующее вхождение тега C-u M-.
  использовать новый файл с тегами M-x visit-tags-table
  поиск по шаблону по всей таблице тегов M-x tags-search
  выполнить query-replace над всеми файлами M-x tags-query-replace
  продолжить поиск или поиск-замену тега M-,

  19.Коммандные процессоры

  Выполнить команду командного процессора M-!
  выполнить команду командного процессора над областью M-|
  пропустить содержимое области через команду командного процессора C-u M-|
  запустить командный процессор в окне *shell*                         M-x shell

  20.Прямоугольные области

  скопировать прямоугольную область в регистр C-x r r
  удалить прямоугольную область C-x r k
  вставить последную уничтоженную прямоугольную область C-x r y
  открыть прямоугольную область, сдвигая текст вправо C-x r o
  очистить прямоугольную область C-x r c
  предварить каждую строку строкой текста C-x r t

  21.Сокращения

  добавить глобальное сокращение C-x a g
  добавить локальное для режима сокращение C-x a l
  добавить глобальное значение для данного сокращения C-x a i g
  добавить специфическое для режима значение данного сокращения C-x a i l
  явно вставить значение для сокращения C-x a e
  динамически дополнить предыдущее слово M-/

  22.Регулярные выражения

  любой одиночный символ (за исключением символа новой строки) . (dot)
  ноль или более повторений *
  одно или более повторений +
  ноль или одно повторение ?
  экранировать специальный символ c  \c
  выбор между альтернативами (“или”) \|
  группировка  \ ( ... \ )
  текст в n-й группе \n
  граница слова \b
  не граница слова \B

  объект	|	начало  соответствия	|	конец   соответствия

  строка             начало  соответствия     ˆ          конец   соответствия   $
  слово		начало  соответствия   \<		конец   соответствия   \>
  буфер            начало  соответствия  \‘              конец   соответствия   \’

  класс символов        соответ-ствует им      соответствует   другим
  явный набор             соответ-ствует им [...]     соответствует   другим   [ ^... ]
  символ с синтаксисом c		соответ-ствует им \c  соответствует   другим \Sc
  смвол-буква им \w другим \W

  23.Международные наборы символов

  выбрать язык C-x RET l
  показать все возможные методы ввода M-x list-input-methods
  разрешить или запретить метод ввода C-\
  установить систему кодирования для следующей команды C-x RET c
  показать список всех систем кодирования M-x list-coding-systems
  выбрать предпочтительную систему кодирования M-x prefer-coding-system

  24.Информация (система Info )

  запустить систему доступа к документации C-h i
  найти указанную функцию или переменную в документации C-h S
  Перемещение внутри узла (нодами):
  прокрутка вперед SPC
  прокрутка назад DEL
  перейти к началу узла  .(dot)
  Перемещение между узлами:
  следующий узел n
  предыдущий узел p
  перейти к
  верхнему узлу u
  выбрать пункт меню по имени m
  выбрать n-й пункт меню по номеру (1–9) n
  перейти по ссылке (возврат с помощью l)f
  возвратится к последнему просмотренному узлу l
  возвратится к узлу-каталогу d
  Перейти к верхему узлу файла t
  перейти к узлу, заданному именем g

   Другие команды:
   запустить учебник по системе документации h
  поиск темы в индексе i
  поиск в узлах с помощью регулярных выражений s
  прекратить работу с документацией q

  25.Регистры

  сохранить область в регистре C-x r s
  вставить содержимое регистра в буфер C-x r i
  сохранить положение курсора в регистре C-x r SPC
  перейти к положению курсора, сохраненному в регистре C-x r j

  26.Клавиатурные макросы

  начать определение клавиатурного макроса C-x (
  закончить определение клавиатурного макроса C-x )
  выполнить последний определенный макрос C-x e
  дополнить последний определенный макрос C-u C-x (
  задать имя для последнего определенного макроса M-x name-last-kbd-macro
  вставить в буфер определение макроса на языке Lisp M-x insert-kbd-macro

  27.Комманды связанные с Emacs Lisp

  вычислить выражение перед курсором C-x C-e
  вычислить текущую функцию defun C-M-x
  вычислить область как выражение M-x eval-region
  считать и вычислить выражение из минибуфера M-:
  загрузить из стандартного системного каталога M-x load-library

  28.Простая настройка

  настроить переменные и оформление (faces)  M-x customize
  Создание глобальных привязок клавиш (ключей) на Emacs Lisp (примеры):
  (global-set-key "\C-cg" ’goto-line)
  (global-set-key "\M-#" ’query-replace-regexp)

  29.Написание комманд

  	(defun <command-name> (<args>)
  	"<documentation>" (interactive "<template>")
  	<body>)
  Пример:

  	(defun this-line-to-top-of-window (line)
  	"Reposition line point is on to top of window.
  	With ARG, put point on line ARG."
  	(interactive "P")
  	(recenter (if (null line)
  	0
  	(prefix-numeric-value line))))

  Спецификация
  interactive
  сообщает о том, что аргумент надо считывать интерактивно. Для дополни-
  тельной информации наберите
  C-h f interactive
  .
** Умное назначение горячих клавиш в Emacs

- Note taken on [2018-02-15 Чтв 11:03] \\
  ##    *Умное назначение горячих клавиш в Emacs*
  Рано или поздно пользователям Emacs приходится переназначать горячие клавиши. Даже те, кто по идеологическим причинам используют дефолтные сочетания, приходят к тому, что нужно назначить на часто-употребляемую команду более простое сочетание клавиш или повесить hotkey на свой собственный скрипт. В интернетах советуют делать это как-то так:
  ```
  (global-set-key (kdb "C-a") 'mark-whole-buffer)
  ```
  Это какое-то время работает, пока не находится плагин, который переопределяет выбранное сочетание на что-то свое...
  Происходит это по той причине, что Emacs назначает глобальным сочетаниям клавиш минимальный приоритет, выше приоритет будет у сочетаний определенных в "основном режиме" (major-mode) и самый высокий у тех, что определены во "вспомогательном режиме" (minor-mode). Так же стоит отметить, что поскольку minor-mode может быть загружен не один, то среди них приоритет будет определятся порядком загрузки.
  Отсюда следует, что выходом из создавшегося положения, является создание своего собственного minor-mode и навешивание горячих клавиш уже в нем. Делается это не сложно:
  ```
  (defvar cfg-mode-map (make-sparse-keymap))

  (define-minor-mode cfg-mode
    "cfg-mode"
    :lighter " cfg"
    cfg-mode-map)
  ```
  Тут мы при помощи макроса "define-minor-mode" определяем наш режим "cfg-mode" (по соглашению название режима должно иметь постфикс "-mode"), ключ "lighter" определяет, то, как наш режим будет отображаться в строке состояния (mode-line), а к переменной "cfg-mode-map" мы будем привязывать интересующие нас горячие клавиши, которые будут ассоциированы с нашим режимом. Так же предусмотрим две полезные функции, при помощи которых мы сможем включать и выключать наш режим для каждого буфера:
  ```
  (defun turn-on-cfg-mode ()
    (interactive)
    (cfg-mode t))

  (defun turn-off-cfg-mode ()
    (interactive)
    (cfg-mode -1))
  ```
  И что-бы не загружать режим каждый раз отдельно, сделаем его глобальным:
  ```
  (define-globalized-minor-mode global-cfg-mode cfg-mode turn-on-cfg-mode)
  ```
  Тут "global-cfg-mode" это имя глобального режима, который будет автоматически включать наш режим "cfg-mode" во всех буферах.
  Тут есть один нюанс, в мини буфере все же стоит оставить те горячие клавиши, которые были определены другими плагинами, иначе мы просто не сможем воспользоваться функциональностью этих плагинов. Поэтому добавляем хук, который выключит режим "cfg-mode" в минибуфере:
  ```
  (add-hook 'minibuffer-setup-hook 'turn-off-cfg-mode)
  ```
  Я уже выше писал, что при загрузке другого minor-mode он может переопределить наши горячие клавиши, что бы этого не произошло, нужно после загрузки каждой новой библиотеки "пододвигать" наши сочетания на самое приоритетное место. Для этого расширим системную функцию, которая отвечает за загрузку emacs-lisp библиотек и после того как она отработает, удалим и снова добавим горячие клавиши привязанные к "cfg-mode", тем самым сделав их самыми приоритетными:
  ```
  (defadvice  (after cfg-keybindings-priority)
    ( (not (eq (car (car minor-mode-map-alist)) 'cfg-mode))
        ( ((mykeys (assq 'cfg-mode minor-mode-map-alist)))
          (assq-delete-all 'cfg-mode minor-mode-map-alist)
          (add-to-list 'minor-mode-map-alist mykeys))))
  (ad-activate 'load)
  ```
  Еще один подводный камень, это fundamental-mode. Дело в том, что некоторые плагины, в частности htmlize, который генерирует html файл с подсветкой синтаксиса, умудряются открывать буфер в fundamental-mode, без загрузки каких-либо дополнительных режимов, что естественно приводит к тому, что все определенные нами горячие клавиши - перестают работать. Для того, что бы побороть это, будем привязывать наши хоткеи одновременно к режиму cfg-mode и устанавливать их как глобальное сочетание клавиш, т.к. для fundamental-mode глобальные хоткеи останутся нетронутыми. Что бы вручную по два раза не определять одни и те же команды, можно сделать функцию, которая получая список из (hotkey/command) одновременно применяла его для минорного режима и добавляла в global key map:
  ```
  (defun lcl:get-hotkeys ()
    (list
     (list "C-x u" 'undo-tree-visualize)
     ...
     (list "M-Z" 'undo-tree-redo)
     (list "M-z" 'undo-tree-undo)
     ))

  (defun cfg:cfg-hotheys (map)
    (dolist (k (lcl:get-hotkeys))
      ( k
        ( ((key (kbd (car k)))
              (func (car (cdr k))))
          (define-key map key func)
          (global-set-key key func)))))

  (cfg:cfg-hotheys cfg-mode-map)
  ```
  Все вместе это будет выглядеть вот так:
  ```
  (defvar cfg-mode-map (make-sparse-keymap))

  (define-minor-mode cfg-mode
    "cfg-mode"
    :lighter " cfg"
    cfg-mode-map)

  (defadvice  (after cfg-keybindings-priority)
    ( (not (eq (car (car minor-mode-map-alist)) 'cfg-mode))
        ( ((mykeys (assq 'cfg-mode minor-mode-map-alist)))
          (assq-delete-all 'cfg-mode minor-mode-map-alist)
          (add-to-list 'minor-mode-map-alist mykeys))))
  (ad-activate 'load)

  (defun turn-on-cfg-mode ()
    (interactive)
    (cfg-mode t))

  (defun turn-off-cfg-mode ()
    (interactive)
    (cfg-mode -1))

  (define-globalized-minor-mode global-cfg-mode cfg-mode turn-on-cfg-mode)

  (defun lcl:get-hotkeys ()
    (list
     (list "C-x u" 'undo-tree-visualize)
     ...
     (list "M-Z" 'undo-tree-redo)
     (list "M-z" 'undo-tree-undo)))

  (defun cfg:cfg-hotheys (map)
    (dolist (k (lcl:get-hotkeys))
      ( k
        ( ((key (kbd (car k)))
              (func (car (cdr k))))
          (define-key map key func)
          (global-set-key key func)))))

  (defun cfg:cfg ()
    (add-hook 'minibuffer-setup-hook 'turn-off-cfg-mode)
    (cfg:cfg-hotheys cfg-mode-map)
    (global-cfg-mode))
  ```
  Теперь для инициализации всего этого хозяйства достаточно вызывать функцию "cfg:cfg"
** Управление Emacs

- Note taken on [2018-02-15 Чтв 11:04] \\
  Сочетание клавиш 	Команда 	Действие
  C-p 	previous-line 	Вверх на одну строку
  C-n 	next-line 	Вниз на строку
  C-f 	forward-char 	Вперёд на один символ
  C-b 	backward-char 	Назад на один символ
  C-a 	beggining-of-line 	Начало строки
  C-e 	end-of-line 	Конец строки
  C-v 	scroll-up 	Вниз на одну страницу
  M-v 	previous-page 	Вверх на одну страницуУправление Emacs
  M-f 	next-word 	Вперёд на одно слово
  M-b 	previous-word 	Назад на одно слово
  M-< 	beginning-of-buffer 	В начало буфера
  M-> 	end-of-buffer 	В конец буфера
  C-g 	keyboard-quit 	Закончить (прервать) текущую операцию
  	goto-line 	Переход на заданную строку

  Команды работы с текстом:
  Сочетание клавиш 	Команда 	Действие
  C-d 	delete-char 	Удаление символа перед точкой
  M-d 	kill-word 	Удалить следующее слово
  C-k 	kill-line 	Удалить текст до конца строки
  M-k 	kill-sentence 	Удалить текст до конца предложения
  M-\ 	delete-horizontal-space 	Удалить все пробелы и знаки табуляции вокруг точки
  C-q 	quoted-insert 	Вставка символа, соответствующего нажатой клавише или сочетанию, даже если это управляющая последовательность
  M-q 	fill-paragraph 	Выравнивает текст в текущем параграфе
  Команды работы с пометками и регионами:
  Сочетание клавиш 	Команда 	Действие
  C-space 	set-mark-command 	Установить пометку в точке
  C-@ 	set-mark-command 	Установить пометку в точке
  C-x C-x 	exchange-point-and-mark 	Поменять местами точку и начало пометки
  	mark-whole-buffer 	Пометить весь буфер
  C-w 	kill-region 	Удаление выделенной области в список удалений
  M-w 	kill-ring-save 	Копирование выделенной области в список удалений
  C-y 	yank 	Вставка текста из списка удалений в текущую позицию
  M-y 	yank-pop 	Последовательная вставка текста из списка удалений
  C-x x N 	copy-to-register 	Копировать отмеченный текст в регистр (N может быть буквой или цифрой, позволяя использовать множество регистров)
  C-x g N 	insert-register 	Вставляет в точку содержимое регистра N
  M-\ 	indent-region 	Выравнивание строк выделенного фрагмента
  Команды поиска и замены:
  Сочетание клавиш 	Команда 	Действие
  C-s 	isearch-forward 	Поиск строки вперёд
  C-r 	isearch-backward 	Поиск строки в обратном направлении
  	replace-string 	Поиск и замена строки
  	replace-regexp 	Поиск и замена с использованием регулярного выражения
  M-% 	query-replace 	Поиск и замена с запросом
  Команды работы с файлами буферами и окнами:
  Сочетание клавиш 	Команда 	Действие
  C-x C-f 	find-file 	Открыть файл на диске
  C-x C-s 	save-buffer 	Сохранить буфер на диске
  C-x C-w 	write-file 	Сохранить буфер в файле с новым именем
  C-x C-b 	list-buffers 	Отобразить список открытых буферов в новом окне
  C-x b 	switch-to-buffer 	Переключиться в другой буфер в текущем окне
  C-x C-c 	save-buffers-kill-emacs 	Перед выходом из редактора запросить о необходимости сохранения изменённых файлов
  C-x i 	insert-file 	Вставить содержимое файла в буфер в текущую позицию
  C-x 0 	delete-window 	Закрыть текущее окно (при этом буфер не удаляется)
  C-x 1 	delete-other-windows 	Закрыть все окна кроме текущего
  C-x 2 	split-window-vertically 	Разделить окно по горизонтали
  C-x o 	other-window 	Переход в другое окно
  Команды работы со справочной системой:
  Сочетание клавиш 	Команда 	Действие
  C-h ? 	help-for-help 	Информация об использовании справочной системы
  C-h t 	help-with-tutorial 	Использовать интерактивный учебник
  C-h f 	describe-function 	Показать справку по функции
  C-h v 	describe-variable 	Показать справку по переменной
  C-h k 	describe-key 	Показать данные, о том, что делает последовательность клавиш
  C-h a 	apropos 	Поиск в справке по строке/регулярному выражению
  C-h F 	view-emacs-FAQ 	Показать Emacs FAQ
  C-h i 	info 	Показать документацию по Emacs (Info)
  Прочие основные команды Emacs:
  Сочетание клавиш 	Команда 	Действие
  M-x command 		Выполнить команду Emacs с именем command
  C-x u 	undo 	Отменить последнюю операцию
  C-x r m 	bookmark-set 	Установить закладку. Полезно при поиске
  C-x r b 	bookmark-jump 	Перейти к закладке
** Это учебник по Emacs

- Note taken on [2018-02-15 Чтв 11:06] \\
  Это учебник по Emacs

  Команды Emacs'а обычно содержат клавишу CONTROL (иногда обозначается как CTRL или CTL) или клавишу META. На некоторых клавиатурах клавиша META обозначается ALT или EDIT или еще как-нибудь (например, на Windows-клавиатурах это может быть клавиша Start). Если у вас нет клавиши META, вы можете использовать вместо нее ESC. Вместо того, чтобы писать META или CONTROL каждый раз, когда мы хотим обозначить команду, содержащую эти клавиши, мы будем использовать аббревиатуры:

   C-  означает: удерживая CONTROL, нажать . Таким образом,
  	  C-f означает: удерживая CONTROL, нажмите клавишу f.
   M-  означает: удерживая META, нажать .  Если клавиша META
  	  отсутствует, сначала нажмите , отпустите, потом нажмите
  	  клавишу .

  Чтобы закончить работу с Emacs'ом, наберите C-x C-c (два символа). Символы ">>" в начале строки говорят о том, что вам предлагается попробовать команду. К примеру:

  >>Сейчас наберите C-v (смотреть следующую страницу), чтобы перейти к следующей странице. (смелее, удерживая CTRL нажмите v). Впредь, делайте это каждый раз, когда вы дочитываете страницу.

  Имейте ввиду, что при пролистывании две строчки предыдущей страницы оказываются вверху экрана, чтобы вы могли какбы продолжить чтение.

  Первая вещь, которой вам нужно научиться, это перемещение по тексту. Вы уже знаете, что продвинуться на страницу вперед можно с помощью команды C-v. Чтобы пролистать страницу назад, нажмите M-v (удерживая клавишу META, нажмите v, или введите v, если у вас нет клавиши META, EDIT или ALT).

  >>  Попробуйте несколько раз понажимать M-v и C-v.

  КОНСПЕКТ

  Следующие команды используются для перемещения по страницам:

  	C-v	Перейти на одну страницу вперед
  	M-v	Перейти на одну страницу назад
  	C-l	Очистить страницу и заново перерисовать все ее
  		содержимое, причем строка, на которой находится курсор,
  		оказывается посередине экрана.
  		(Это control-L, а не control-1).

  >> Найдите курсор и запомните текст рядом с ним. Потом нажмите C-l. Опять найдите курсор и обратите внимание на то, что он стоит на том же самом тексте.
  ПРОСТЕЙШЕЕ УПРАВЛЕНИЕ КУРСОРОМ

  Перелистывание страниц полезно, но как вам переместиться в конкретное место в тексте на экране?

  Есть несколько способов добиться этого. Простейший путь - использовать команды C-p, C-b, C-f и C-n. Эти команды перемещают курсор на одну строчку или столбец в определенном направлении. Вот таблица, показывающая, каким направлениям соответствуют эти команды:

  		Предыдущая (previous) строка, C-p
  				  :
  				  :
  Назад (backward), C-b . . . . . Курсор . . . . . Вперед (forward) C-f
  				  :
  				  :
  		   Следующая (next) строка, C-n

  >> Переместите курсор на строку в середине диаграммы используя C-n или C-p. Потом нажмите C-l, чтобы посмотреть на всю диаграмму в центре экрана.

  Вам, вероятно, будет проще запомнить эти команды по первым буквам: P - previous, N - next, B - backward и F - forward (англ.: предыдущий, следующий, назад, вперед). Это простейшие команды перемещения курсора, вы будете использовать их постоянно, поэтому лучше выучить их сразу.

  >> Нажмите C-n несколько раз, чтобы передвинуть курсор на эту строчку.

  >> Переместите курсор вперед с помощью C-f а потом несколько раз нажмите С-p. Обратите внимание, как работает C-p, когда курсор находится в середине строки.

  Каждая строка оканчивается символом "перенос" (newline), служащим для отделения ее от следующей строки. Последняя строка в файле по идее тоже должна оканчиваться переносом (но Emacs не требует, чтобы это обязательно было так).

  >> Попробуйте нажать C-b в начале строки. Курсор переместится в конец предыдущей строки. Это происходит, потому что курсор перескакивает через перенос.

  C-f перескакивает через перенос также, как C-b.

  >> Нажмите C-b еще несколько раз, чтобы перевести курсор в середину строки. Потом нажмите несколько раз C-f, чтобы вернуть курсор в конец. И еще раз C-f, чтобы переместить курсор на следующую строку.

  Когда вы перемещаете курсор за нижнюю или верхнюю границу экрана, текст, находящийся за границей, появляется на экране. Это называется прокрутка (scrolling). Прокрутка позволяет Emacs'у переместиться в любое место текста не выводя курсор за пределы экрана.

  >> Попробуйте переместить курсор за нижнюю границу экрана с помощью C-n, и посмотрите, что получается.

  Если перемещаться по буквам слишком медленно, вы можете двигаться по словам. M-f (META-f) сдвигает курсор на одно слово вперед, а M-b - на слово назад.

  >> Попробуйте нажать несколько раз M-f и M-b.

  Когда вы в середине слова, M-f перемещает курсор в конец слова. Если вы стоите на пробеле между словами, M-f перемещает курсор в конец следующего слова. M-b работает аналогично в противоположном направлении.

  >> Понажимайте M-f и M-b, чередуя их с C-f и С-b, таким образом вы увидите, как работают M-f и M-b в разных местах внутри и между словами.

  Обратите внимание на связь между C-f, C-b и M-f, M-b. Очень часто META-комбинации используются для операций, связанных со смысловыми единицами языка (словами, предложениями, параграфами), в то время как CONTROL-комбинации работают с простейшими единицами текста (символами, строкаси, и т. п. ), не зависящими от того, какого рода информацию вы редактируете.

  Такая параллель прослеживается между перемещением по строкам и по параграфам: C-a и C-e перемещают курсор в начало и в конец строки, а M-a и M-e - в начало и в конец предложения.

  >> Попробуйте несколько раз C-a и C-e.
  >> Попробуйте несколько раз M-a и M-e.

  Обратите внимание на то, что повторяющиеся C-a не дают никакого эффекта, в то время как повторяющиеся M-a перемещают курсор по предложениям. Хотя это и не является полной аналогией, однако такое поведение выглядит естественным.

  По-английски положение курсора в тексте иногда называется "point". Другими словами, курсор на экране показывает, где находится point в тексте.

  Вот список базовых команд перемещения курсора, включая команды перемещения по словам и по предложениям:

  	C-f	Переместить курсор на символ вперед
  	C-b	Переместить курсор на символ назад

  	M-f	Переместить курсор на слово вперед
  	M-b	Переместить курсор на слово вперед

  	C-n	Переместить курсор на следующую строку
  	C-p	Переместить курсор на предыдущую строку

  	C-a	Переместить курсор в начало строки
  	C-e	Переместить курсор в конец строки

  	M-a	Переместить курсор в начало предложения
  	M-e	Переместить курсор в конец предложения

  >> Попробуйте все эти команды для тренировки: они используются в работе наиболее часто.

  Две другие важные команды перемещения курсора это M-< (META "меньше"), которая перемещает курсор в начало текста, и M-> (META "больше"), которая перемещает курсор в конец текста.

  На большинстве терминалов символ "<" находится над запятой, и вам нужно использовать клавишу SHIFT, чтобы набрать его. На этих терминалах вам также нужно использовать SHIFT, чтобы набрать M-<, без нее у вас получится M-запятая.

  >> Попробуйте M-<, чтобы переместиться в начало учебника. Потом нажмите C-v несколько раз, чтобы вернуться обратно.

  >> Попробуйте M->, чтобы переместиться в начало учебника.Потом нажмите M-v несколько раз, чтобы вернуться обратно.

  Если на вашем терминале есть клавиши перемещения курсора (стрелки), то вы также можете перемещать курсор с их помощью. Но мы рекомендуем выучить для этих целей C-b, C-f, C-n и C-p. Во-первых, они работают на любом терминале. Во-вторых, работая с Emacs'ом, вы обнаружите, что использовать эти CONTROL-комбинации быстрее, чем использовать стрелки (потому что вам не надо снимать руки с положения, используемого для печати десятипальцевым методом). В третьих, если вы привыкнете использовать эти комбинации, вы легко можете выучить другие специальные команды перемещения курсора.

  Большинство команд Emacs'а могут иметь числовой аргумент, и для большинства команд он означает количество повторений. Задать этот аргумент можно нажав C-u и введя число перед тем, как набирать команду. Если у вам есть клавиша META (или EDIT, или ALT), то есть альтернативный путь задания числового аргумента: набрать число, удерживая клавишу META. Мы рекомендуем использовать C-u, ибо это работает на любом терминале.

  К примеру, C-u 8 C-f перемещает курсор вперед на 8 букв.

  >> Попробуйте использовать команду C-n или C-p с числовым аргументом, чтобы переместить курсор к этой строке с помощью одной команды.

  Большинство команд используют числовой аргумент как количество повторений. Некоторые команды-исключения используют его по-другому. C-v и M-v относятся к таким исключениям. Если задан аргумент, они прокручивают экран вверх или вниз на заданное количество строк, а не пролистывают такое количество страниц. Например, C-u 4 С-v прокручивает экран на 4 строки.

  >> Попробуйте набрать C-u 8 C-v.

  Emacs должен прокрутить экран на 8 строк вверх. Если вы хотите вернуться обратно, вы можете задать аргумент для M-v.

  Если вы используете X Window System, то, вероятно, у вас есть прямоугольная область, называемая "полоса прокрутки" (scrollbar), расположенная вдоль правого края окна Emacs'а. Подсвеченный прямоугольничек внутри полосы прокрутки называется "ползунок". Вы можете прокручивать текст, манипулирую полосой прокрутки с помощью мышки.

  >> Попробуйте нажать левую кнопку мыши (делее по тексту: кликнуть) сверху от ползунка. Это прокрутит текст в позицию, определяемую тем, насколько высоко или низко вы кликнули.

  >> Переместите мышь к самому верху или самому низу полосы прокрутки, на треугольную стрелочку "вверх" или "вниз". Кликните левой кнопкой несколько раз: Emacs прокручивает текст по одной строчке в заданном направлении.

  >> Переместите мышь к верху(низу) полосы прокрутки, чуть ниже(выше)треугольной стрелочки. Кликните левой кнопкой несколько раз.Таким образом можно прокручивать текст по станицам.
  УПРАВЛЕНИЕ КУРСОРОМ С ПОМОЩЬЮ X ТЕРМИНАЛА

  Если вы работаете с X терминалом, вам, вероятно, проще будет использовать клавиши дополнительной клавиатуры (keypad) для перемещения курсора. Стрелки влево, вправо, вверх и вниз перемещают курсор в соответствующем направлении; они работают аналогично C-b, C-f, C-p и C-n, но проще набираются и запоминаются. Вы также можете использовать C-влево и C-вправо для перемещения по словам а C-вверх и C-вниз для перемещения по блокам (при редактировании текста - по параграфам). Если у вас есть клавиши HOME (или BEGIN) и END, то они, соответственно, переносят курсор в начало и в конец строки, а C-HOME и C-END - в начало и в конец файла. Если на вашей клавиатуре есть клавиши PgUp (PageUp) и PgDn (Page Down), вы можете использовать их для перемещения на одну страницу назад или вперед, аналогично M-v и C-v.

  Все эти команды могут принимать числовой аргумент, как описано выше. Можно пользоваться сокращенным способом набора: набирать число, удерживая CONTROL или META. Например, что переместиться на 12 слов вправо, наберите C-1 C-2 C-вправо. Это очень просто, потому что вам не нужно отпускать CONTROL во время набора: удерживая эту клавишу наберите 1, 2, вправо.
  КОГДА EMACS ЗАВИСАЕТ

  Если Emacs не реагирует на ваши команды, вы можете вернуть его в интерактивное состояние с помощью команды C-g. Вы также можете использовать C-g, чтобы отменить команду, выполнение которой затянулось.

  Еще C-g можно использовать, чтобы отменить числовой аргумент или начало команды, которую вы раздумали заканчивать.

  >> Наберите C-u 100, чтобы ввести числовой аргумент 100, потом нажмите C-g. Теперь нажмите C-f. Курсор переместится только на один символ вперед, потому что вы отменили аргумент командой C-g.

  Если вы набрали по ошибке, вы также можете использовать C-g, чтобы Emacs "забыл" про это.
  ОТКЛЮЧЕННЫЕ КОМАНДЫ

  Некоторые команды Emacs'а бывают "отключены", чтобы начинающие пользователи не набрали их по ошибке.

  Если вы введете одну из таких команд, Emacs выдаст сообщение о том, какая команда была введена, и спросит, правда ли вы хотите ее выполнить.

  Если вы на самом деле хотите выполнить эту команду, нажмите Пробел в ответ на вопрос, в противном случае нажмите "n".

  >> Наберите C-x n p (это отключенная команда), а потом ответьте "n" на вопрос.

  Emacs может иметь несколько окон, каждое из которых содержит свой собственный текст. Имейте в виду, что "окно" (window) в Emacs'е означает не отдельные перекрывающиеся окна в оконной системе, а разделенные участки внутри одного X окна. (Emacs также может иметь несколько X окон, или "кадров" (frames) в терминологии Emacs'а. Но об этом позже.)

  На данном этапе лучше не углубляться в технику работы с несколькими окнами. Но вам нужно знать как убрать лишние окна, которые могут появиться на экране для вывода помощи или отображения результатов выполнения некоторых команд. Это очень просто:

  	C-x 1    Одно окно (т.е. закрыть все остальные окна).

  То есть CONTROL-x и затем цифра 1. C-x 1 раскрывает окно, в котором находится курсор, на весь экран, тем самым закрывая все остальные окна.

  >> Передвиньте курсор на эту строчку и нажмите C-u 0 C-l.

  (Запомните, что C-l перерисовывает экран. Если задан числовой аргумент x, то это работает как "перерисовать экран и поместить текущую строку на x строк от верха экрана". Таким образом C-u 0 C-l означает "перерисовать экран и поместить текущую строку на самый верх".)

  >> Нажмите C-x 2

  Текущее окно уменьшилось вдвое и появилось еще одно, показывающее то же содержимое.

  >> Нажмите C-x 1, чтобы увидеть, как второе окно будет удалено.
  ВСТАВКА И УДАЛЕНИЕ

  Если вы хотите вставить текст, просто наберите этот текст. Видимые символы, такие как А, 7, * и т.д. воспринимаются Emacs'ом как текст и вставляются немедленно. Return (Enter) используется для того, чтобы вставить перенос (newline).

  Вы можете удалить последний набранный символ с помощью клавиши Delete (Del). В некоторых случаях, клавиша Delete удаляет символ после курсора, а последний введенный символ (символ перед курсором) удаляется с помощью клавиши Backspace. Далее по тексту, для ясности, мы будем говорить "команда удаления последнего символа".

  >>Попробуйте прямо сейчас - наберите строку символов, потом переместитесь в середину и посмотрите, как работают Delete и Backspace в вашем Emacs'e. Не волнуйтесь по поводу этого файла; вы не повредите настоящий учебник. То, что вы видите на экране - это ваша персональная копия.

  В принципе, функции этих клавиш легко настраивается, поэтому вы можете попросить вашего системного администратора сделать так, чтобы они работали как вам удобно.

  Если строка текста слишком длинна и не помещается на экране, она "переносится" на следующую строку. Символ backslash - обратная косая скобка (или загнутая стрелка в XEmacs'е) в конце строки говорит о том, что строка "перенесена".

  >> Набирайте текст, пока не дойдете до правой границы экрана. Продолжайте набирать. Вы увидите, как появится строка-продолжение.

  >> Удерживайте Delete (или Backspace, в зависимости от того, какая клавиша у вас удаляет символ перед курсором) до тех пор, пока строка не уменьшится до ширины страницы. Вы увидите, как "продолжение" исчезнет.

  Вы можете удалять перенос как любой другой символ. Удаление переноса между двумя строками приводит к объединению этих строк в одну. Если результирующая строка окажется слишком длинной, чтобы уместиться по ширине страницы, она будет показана с "продолжением".

  >> Поставьте курсор в начало строки и нажмите Delete (Backspace). Это объединит текущую строку с предыдущей.

  >> Нажмите Return (Enter) чтобы вставить перенос, который вы удалили.

  Помните, что большинство команд Emacs'а, в том числе текстовые символы, могут принимать числовой аргумент. В этом случае символ будет напечатан заданное количество раз.

  >> Попробуйте набрать "C-u 8 *", чтобы написать ********.

  Теперь вы знаете основные способы как вводить текст в Emacs и как исправлять ошибки. Вы также можете удалять целые слова или строки.

  Вот список команд удаления:

  	     удалить символ перед курсором
  	C-d   	     удалить символ после курсора

  	M-   удалить слово перед курсором
  	M-d	     удалить слово за курсором

  	C-k	     удалить от текущего символа до конца строки
  	M-k	     удалить от текущего символа до конца предложения

  Обратите внимание на то, что , C-d и M-, M-d продолжают параллель, начатую C-f и M-f (на самом деле, не является control-последовательностью, но не будем сейчас заострять на этом внимание). C-k и M-k в каком-то смысле аналогичны C-e и M-e.

  Если вы удаляете более одного символа за раз, Emacs запоминает удаленный текст, чтобы вы могли вернуть его назад. Возвращение удаленного текста называется "возврат" (yanking). Вы можете вернуть удаленный текст в том же месте, где вы его удалили, или в каком-нибудь другом месте текста. Вы можете вернуть текст несколько раз, чтобы создать несколько его копий. Команда возврата - C-y.

  Разница между "удалением" (killing) и "стиранием" (deleting) в том, что "удаленные" вещи можно "вернуть" назад, а "стертые" - нет. В общем, команды, удаляющие много текста за раз, сохраняют удаленный текст, а команды, удаляющие только один символ (пробел, перенос), не сохраняют.

  >> Подведите текст к началу этой строки. Нажмите C-k, чтобы удалить ее.

  >> Нажмите C-k еще раз. Вы увидите как в результате будет удален перенос, который заканчивает строку.

  Обратите внимание, что одиночное нажатие C-k удаляет содержимое строки, а повторное - саму строку, сдвигая последующие строки вверх. Команда C-k обрабатывает числовой аргумент (n) специфически: удаляет n строк И их содержимое. То есть тут не просто повторение: C-u 2 C-k удаляет две строки, а нажатие два раза C-k - одну.

  Чтобы вернуть удаленный текст и поместить его туда, где стоит курсор, нажмите C-y.

  >> Попробуйте, нажмите C-y, чтобы вернуть удаленный текст.

  Представьте себе, что C-y возвращает обратно текст, который вы убрали. Имейте ввиду, что если вы нажали несколько C-k подряд, то весь удаленный текст запомнится одним куском, так что C-y вернет все удаленные строки.

  >> Итак, нажмите C-k несколько раз.

  Теперь, чтобы вернуть удаленный текст:

  >> Нажмите C-y.

  >> Потом опустите курсор на несколько строк и нажмите C-y еще раз.

  Теперь вы знаете, как скопировать кусок текста.

  Как быть, если вы удалили какой-то текст, который вы хотели бы в дальнейшем вернуть, а потом удалили что-то еще? C-y вернет только самое последние удаление. Но и предыдущий текст не потерян. Вы можете вернуть его с помощью команды M-y. После того как вы нажали C-y и вернули текст, удаленный в последнюю очередь, M-y будет заменять только что возвращенный кусок текста на более ранние "удаления".

  После того, как вы, нажимая M-y, дойдете до искомого текста, вам не нужно ничего делать, чтобы оставить его - просто продолжайте редактирование, а возвращенный текст останется там, где он появился.

  Если нажать M-y достаточное количество раз, то вы вернетесь в самое начало, то есть к самому первому удалению. Потом опять появится самое последние удаление и так далее по кругу.

  >> Удалите строку(1), переместитесь куда-нибудь, удалите еще строку(2). Нажмите C-y, чтобы вернуть строку 2. Теперь нажмите M-y - это заменит строку 2 на строку 1. Нажмите M-y еще несколько раз и посмотрите, что у вас получается. Продолжайте нажимать эту комбинацию пока не появится строка 2, и еще пару раз. Если хотите, можете попробовать задать команде M-y положительный или отрицательный числовой аргумент.
  ОТМЕНА

  Если вы внесли изменения в текст, а потом решили, что это была ошибка, вы можете отменить изменения с помощью команды (команда взята в квадратные скобки чтобы не спутать латинский символ "u" и русскую букву "и").

  Обычно отменяет изменения внесенные одной командой, если вы повторяете несколько раз то каждое повторение отменяет еще одну команду.

  Однако есть два исключения: команды перемещения курсора и пролистывания экрана не считаются, а обыкновенные символы обычно обрабатываются группами до 20 штук (это сделано для того, чтобы сократить количество нажатий при отмене вставки текста).

  >> Удалите эту строку с помощью C-k а потом нажмите - она должна вернуться обратно.

  C-_ - альтернативная команда отмены, она работает также как , но ее легче набирать несколько раз подряд. Проблема в том, что на некоторых клавиатурах способ набора C-_ весьма неочевиден. Поэтому мы предлагаем оба варианта. На некоторых терминалах, вы можетеиспользовать C-/ вместо C-_.

  Числовой аргумент для команд C-_ (C-/) и работает как количество повторений.
  ФАЙЛЫ

  Для того, чтобы сохранить текст, который вы редактируете, вы должны поместить его в файл. В противном случае он исчезнет, когда вы будете выходить из Emacs'а. Вы помещаете то, что вы пишете, в файл с помощью "сохранения" (saving) файла.

  "Открытие" (finding) файла означает, что вы видите содержимое файла в Emacs'е. Во многих случаях это тоже самое, как если бы вы редактировали сам файл. Тем не менее, изменения, которые вы сделали с помощью Emacs'а, не станут перманентными до тех пор, пока вы не сохраните файл. При сохранении Emacs запоминает изначальный файл под другим именем, на случай, если вы решите, что изменения были внесены по ошибке.

  Внизу экрана вы можете видеть строку, которая начинается и заканчивается знаками "тире" и содержит текст "Emacs: TUTORIAL" (англ.: tutorial - учебник). Эта строка всегда показывает название файла, с которым вы работаете. Сейчас вы просматриваете файл "TUTORIAL", который является вашей персональной копией учебника по Emacs'у. Какой бы файл вы не открыли, его название всегда будет показано в этой строке.

  Команды, отвечающие за открытие и сохранение файлов, состоят из двух символов. Оба начинаются с символа Control-x. Существует целая серия команд, начинающихся с Control-x, многие из них отвечают за работу с файлами, буферами и связанными с этим вещами. Эти команды состоят из одного, двух, трех и четырех символов.

  Еще одна особенность команды открытия файла заключается в том, что вам нужно указать имя файла, который вы хотите открыть. Говорится, что команда "читает аргумент с терминала" (в данном случае "аргумент" - это имя файла). После того как вы введете команду

  	C-x C-f    Открыть файл

  Emacs попросит вас ввести имя файла. Ввод имени будет отображаться на самой нижней строке экрана. Эта строка называется минибуфер (minibuffer) и используется для ввода вещей подобного рода. Вы можете использовать стандартные команды Emacs'а для редактирования имени файла.

  Вы можете отменить ввод имени файла (или любой другой ввод в минибуфере) с помощью команды C-g.

  >> Введите C-x C-f, а потом нажмите C-g. Таким образом вы выйдете из минибуфера и отмените команду C-x C-f, которая использовала минибуфер. Так что никакой файл вы не откроете.

  Когда вы ввели имя файла, нажмите чтобы закончить ввод. В таком случае команда C-x C-f выполнится и откроет файл, который вы выбрали. Минибуфер исчезнет по окончанию выполнения команды C-x C-f.

  Через небольшое время содержимое файла появится на экране и вы сможете начать редактирование. Когда вы захотите записать изменения, введите команду

  	C-x C-s   Сохранить файл

  Таким образом вы скопируете текст из Emacs'а в файл. Когда вы будете делать это первый раз, Emacs скопирует исходный файл под другим именем, чтобы можно было вернуть изменения. Другое имя будет состоять из исходного имени файла и символа "~" в конце.

  После сохранения Emacs пишет имя, под которым от файл был сохранен. Рекомендуется сохраняться почаще, чтобы вы не потеряли слишком много работы в случае сбоя системы.

  >> Сохраните вашу копию учебника: нажмите C-x C-s. Внизу появится надпись "Wrote ...TUTORIAL". (англ.: учебник записан).

  Вы можете открыть файл, чтобы просмотреть его или отредактировать. Вы также можете открыть файл, который еще нет на диске. Таким образом вы создаете файл с помощью Emacs'а: открываете несуществующий файл, который вначале, естественно, пуст, и начинаете вводить текст. Когда вы потребуете "сохранить" файл, Emacs действительно создаст его и запишет туда текст который вы ввели. После этого вы можете считать, что редактируете существующий файл.
  БУФЕРЫ

  Если вы открываете второй файл с помощью C-x C-f, то первый файл остается в Emacs'е. Вы можете переключиться обратно открыв первый файл снова. Таким образом вы можете держать в Emacs'е несколько файлов.

  >> Создайте файл "foo" набрав C-x C-f foo . Потом напишите в нем что-нибудь и сохраните "foo" с помощью C-x C-s. И под конец наберите C-x C-f TUTORIAL , чтобы вернуться в учебник.

  Emacs хранит содержимое каждого открытого файла в структуре под названием "буфер" (buffer). Открытие файла создает новый буфер в Emacs'е. Чтобы посмотреть список буферов, наберите

  	C-x C-b   Список буферов

  >> Нажмите C-x C-b.

  Вы видите, что каждый буфер имеет название, он также может быть связан с файлом, в котором хранится его содержимое. Некоторые буферы не связаны с файлами. Например, буфер под названием "*Buffer List*" (список буферов) не прикреплен ни к какому файлу. Это как раз тот буфер, который был создан и показан командой C-x C-b. ЛЮБОЙ текст, который вы видите в окне Emacs'а является частью некоторого буфера.

  >> Нажмите C-x 1, чтобы убрать окно со списком буферов.

  Если вы внесли изменения в один файл, а потом открыли другой, то это не приведет к записи первого файла. Все изменения остаются внутри Emacs'а, в буфере, связанном с этим файлом. Создание или редактирование второго файла никак не отражается на буфере первого файла. Это очень удобно, но это также означает, что вам нужен простой способ сохранить буфер первого файла. Переключаться обратно с помощью C-x C-f, чтобы нажать C-x C-s, может быть неудобно, вместо этого существует команда

  	C-x s     Сохранить некоторые буферы

  C-x s по очереди предложит вам сохранить все буферы, которые содержат изменения но не были сохранены.

  >> Напишите строку текста, а потом нажмите C-x s. Вам будет предложено сохранить буфер TUTORIAL.Ответьте на вопрос "y": буфер будет сохранен.
  ИСПОЛЬЗОВАНИЕ МЕНЮ

  Если вы работаете с X терминалом, то, наверное, обратили внимание на меню вверху Emacs'овского окна. Вы можете использовать его для доступа к наиболее часто используемым функциям, таким как "find file" (англ.: открыть файл). Вначале это покажется вам более удобным, чем набирать команды с клавиатуры, потому что не надо запоминать соответствующие комбинации клавиш. Однако по мере осваивания Emacs'а, вы будете запоминать эти комбинации (в меню они написаны рядом с названиями команд), и вам будет быстрее пользоваться клавиатурой.

  Имейте ввиду, что многие пункты меню не имеют эквивалентной клавиатурной команды. Например, меню Буферы (Buffers) содержит список всех доступных буферов, отсортированный по времени последней активизации. Вы можете переключиться в любой буфер просто выбрав его название в этом меню.
  ИСПОЛЬЗОВАНИЕ МЫШИ

  Когда Emacs работает под X, он полностью поддерживает мышь. Вы можете позиционировать курсор кликнувшись левой кнопкой в соответствующем месте. Выделение производится путем удержания левой кнопки во время перемещения мыши. Альтернативный способ: кликнуться левой кнопкой в начале помечаемого участка текста, и еще раз, удерживая Shift, кликнуться в конце.

  Вы можете удалить помеченный текст в помощью C-w или выбрав пункт Cut (англ.: вырезать) из меню Edit (англ.: редактировать). Имейте ввиду, что C-w просто сохраняет текст в Emacs'е (как команда C-k, описанная выше), а Cut к тому же еще помещает вырезанный текст в буфер обмена X (X clipboard), откуда его можно вставить в другие программы.

  Чтобы вставить текст из буфера обмена X, используйте команду Paste (англ.: вставить) из меню Edit.

  Средняя кнопка мыши обычно используется для выбора позиций, которые существуют в некоторых буферах. Например, если вы войдете в Info (англ.: информация) - документацию по Emacs'у, используя команду C-h i или через меню Help (англ.: помощь), вы можете выбирать подсвеченные ссылки, кликаясь на них средней кнопкой. Аналогично, когда вводится имя файла (например, при открытии файла), то при нажатии TAB откроется окно с возможными вариантами имени, нужный файл можно выбрать опять-таки с помощью средней кнопки.

  Правая кнопка мыши вызывает всплывающее меню (popup menu). Содержимое этого меню зависит от того, где вы находитесь, и содержит, как правило, наиболее часто используемые в этом контексте команды.

  >> Нажмите правую кнопку в этом окне.

  (Чтобы меню не пропадало, нужно удерживать правую кнопку).
  РАСШИРЕННЫЙ НАБОР КОМАНД

  Существует еще много, очень много команд Emacs'а, которые, вероятно, могут занять все control- и meta- комбинации. Решением этой проблемы является команда X (от англ. eXtend - расширять). Она существует в двух видах:

  	C-x	Символьное расширение.  Далее следует один или
  		несколько символов.
  	M-x	Вызов команды по названию.  После нажатия M-x нужно
  		ввести название команды.

  С помощью команды расширения вызываются функции, которые иногда бывают полезны, однако используются реже, чем, например, C-k или C-u. Вы уже встречали такие "расширенные" команды: C-x C-f - открытие файла и C-x C-s - запись. Другой пример - команда выхода из Emacs'а - C-x C-c (не волнуйтесь о несохраненных файлах; C-x C-c предложит сохранить все измененные файлы перед тем, как закрыть Emacs).

  C-z - команда *временного* выхода из Emacs'а, т.е. вы временно оказываетесь в командном интерпретаторе и можете вернуться в Emacs не загружая его по новой. На системах, которые имеют такую возможность, C-z "приостанавливает" (suspends) Emacs - вы возвращаетесь в командную строку, но Emacs остается загруженным в память. В большинстве систем вы можете вернуться в Emacs с помощью команды "fg" или набрав "%emacs". Emacs под X по команде C-z просто сворачивает окно.

  В системах, где "сворачивание" не реализовано, C-z загружает новый командный интерпретатор, что позволяет вам выполнить какие-то команды и после этого вернуться в Emacs.

  Если в вашей системе достаточно памяти, то проще не выходить из Emacs'а, а приостанавливать его: когда Emacs понадобится, не надо будет загружать его заново. Чтобы выйти из Emacs'а окончательно, используйте C-x C-c. Осмысленно выходить из Emacs'а, когда вы собираетесь остановить работу системы или если Emacs был запущен из под какой-нибудь почтовой или другой прикладной программы, так как эта программа может не знать, как обрабатывать "приостановку" Emacs'a.

  Существует множество C-x команд. Вот список тех, которые вы уже знаете:

  	C-x C-f		Открыть файл
  	C-x C-s		Сохранить файл
  	C-x C-b		Список буферов
  	C-x C-c		Выход из Emacs'а
  	C-x u		Отмена

  Запуск команд по имени применяется для вызова функций, которые используются менее часто или только в определенных режимах. Примером может служить команда replace-string (англ.: заменить строку ),которая заменяет одну последовательность символов на другую по всему тексту. Когда вы нажимаете M-x, Emacs предлагает вам ввести имя команды в минибуфере внизу экрана. В случае вызова команды replace-string вы можете набрать "repls" - Emacs сам закончит название команды, а вам останется только нажать .

  Команда replace-string требует два аргумента - _что_ заменять и _чем_ заменять. Ввод каждого аргумента оканчивается нажатием .

  >> Подведите курсор к пустой строке на две строки ниже этой. Нажмите M-x repl sизмениласьпоменялась.

  Обратите внимание, как изменилась эта строка: вы заменили слова и-з-м-е-н-и-л-а-с-ь на "поменялась" с текущей позиции курсора и до конца текста.
  АВТОМАТИЧЕСКОЕ СОХРАНЕНИЕ

  Если вы внесли изменения в файл но еще не сохранились, то, в случае сбоя системы, они могут быть потеряны. Чтобы избежать этого, Emacs периодически пишет "автосохранение" для каждого редактируемого файла. Автосохранение начинается и заканчивается символом #. Например, если вы редактируете файл "hello.c", то имя автосохранения будет "#hello.c#". Оно удаляется, когда вы сохраняете файл стандартным путем.

  В случае сбоя системы, вы можете можете избежать потери информации следующим образом: откройте свой рабочий файл (именно его, а не автосохранение), после чего наберите "M-x recover file". Emacs запросит подтверждения, ответьте "yes" - ваш файл будет восстановлен из последнего автосохранения.
  ОБЛАСТЬ ПОДСКАЗКИ (ECHO AREA)

  Если Emacs видит, что вы набираете команды медленно, то он будет показывать вам уже набранную часть команды в области подсказки - на нижней строке экрана.
  СТРОКА СОСТОЯНИЯ (MODELINE)

  Вторая снизу строка - строка состояния. Обычно там написано что-то вроде

  --**-Emacs: TUTORIAL          (Fundamental)--670--68%----------------

  Это строка показывает полезную информацию о режимах Emacs'а и о тексте, который вы редактируете.

  Вы уже знаете, что означает текст сразу после надписи "Emacs:" - это имя файла, который вы открыли. -NN%- показывает текущую позицию в тексте: NN процентов файла находятся сверху от видимой страницы. Если вы находитесь в начале файла, то там будет написано не 00%, а -Top- (англ.: верх). Соответственно, в конце файла будет написано -Bot- (bottom - англ.: низ). Если файл такой маленький, что целиком умещается на экране, то надпись будет гласить -All- (англ.: весь).

  Звездочки в начале строки говорят о том, что в файл после последней записи были внесены изменения. Сразу после открытия или сохранения файла звездочек там нет.

  Часть строки состояния между скобками содержит информацию о том, в каком режиме редактирования вы находитесь. Режим по умолчанию - Fundamental (англ.: базовый), как раз сейчас он активен. Это пример "основного режима" (major mode).

  В Emacs'е существует множество основных режимов. Некоторые из них предназначены для редактирования исходных текстов на разных языках программирования, например Lisp mode, и/или текста, например, Text mode. (mode - англ.: режим). В каждый момент времени активен один и только один основной режим, и его название всегда написано в строке состояния там, где сейчас вы видите "Fundamental".

  Каждый основной режим заставляет некоторые команды работать по-разному. Например, так как в разных языках программирования комментарии ставятся по-разному, то и команда комментирования участка кода в разных режимах работает по-своему. Каждому основному режиму соответствует образованная от его названия расширенная команда, переключающая Emacs в этот режим. Например, M-x fundamental-mode - команда переключения в режим Fundamental. Если вы собираетесь редактировать простой текст, например, этот файл, то вам резонно использовать режим Text.

  >> Наберите M-x text-mode.

  Функционирование команд, которые вы изучили выше, практически не изменилось. Однако, вы можете заметить, что команды M-f и M-b теперь воспринимают апостроф как часть слова. А раньше, в режиме Fundamental, апостроф интерпретировался как разделитель слов.

  Обычно основные режимы вносят небольшие изменения, наподобие этого, то есть большинство команд "делают ту же работу", но немного по-разному.

  Чтобы посмотреть документацию на текущий основной режим, нажмите C-h m.

  >> Нажмите C-u C-v, чтобы перенести эту строку вверх экрана. Нажмите C-h m, чтобы посмотреть, чем режим Text отличается от режима Fundamental. Нажмите q, чтобы закрыть окно с документацией.

  Основные режимы называются основными, так как есть еще режимы вспомогательные. Вспомогательные режимы являются не альтернативой основных, а их небольшими модификациями. Каждый вспомогательный режим может быть включен и выключен сам по себе, независимо от других вспомогательных режимов и независимо от основного режима. Таким образом, вы можете не включать их вообще или включить один или использовать комбинацию из нескольких.

  Один вспомогательный режим может быть очень полезен при наборе обыкновенного текста, это режим Auto Fill (англ.: автоматическое заполнение). В нем Emacs автоматически переносит строку, разбивая ее между словами, когда длина строки превышает некое установленное значение.

  Вы можете включить этот режим, набрав M-x auto-fill-mode. Выключение режима происходит точно также. Когда режим активен, эта команда выключает его, а когда не активен - включает.

  >> Наберите M-x auto-fill-mode. Теперь набирайте что-нибудь вроде "йцук " много раз, пока Emacs не перенесет строку. Важно оставлять в строке пробелы, так как Emacs разбивает строку только по ним.

  Перенос осуществляется, как правило, по 70-символьной границе, но вы можете изменить ее с помощью команды C-x f. Границу надо задать в качестве аргумента для этой команды.

  >> Введите "C-x f" с аргументом 20 (C-u 20 C-x f). Наберите какой-нибудь текст чтобы убедиться, что Emacs переносит строки по новой границе. Верните границу обратно с помощью C-u 70 C-x f.

  Если вы внесли изменения в середине параграфа, Emacs не станет выравнивать весь параграф.

  Чтобы сделать это, нужно нажать M-q. Команда M-q выравнивает параграф, на котором стоит курсор.

  >> Перенесите курсор на предыдущий параграф и нажмите M-q.
  ПОИСК

  Emacs умеет искать строки (то есть слова или непрерывные последовательности символов) вперед или назад по тексту. Поиск строки является командой переноса курсора, то есть курсор ставится на то место, где найдена искомая строка.

  Поиск в Emacs'е отличается от поиска в большинстве других редакторов тем, что он "инкрементный" (incremental). Это означает, что поиск происходит по мере того, как вы вводите строку поиска. C-s и C-r, соответственно, команды поиска "вперед" и "назад" (от англ. search - искать и reverse - обратный). Только НЕ НАДО пробовать их прямо сейчас.

  Когда вы нажмете C-s вы увидите строку "I-search" в минибуфере. Это говорит о том, что запущен инкрементный поиск, и Emacs ждет, что вы начнете вводить строку, которую предстоит искать. заканчивает поиск.

  >> Поставьте курсор в начало строки с английским текстом, отцентрируйте ее (C-l) и нажмите C-s, чтобы начать поиск. МЕДЛЕННО, по одному символу за раз, наберите слово "cursor", делая паузу после каждой буквы, обращая внимание на поведение курсора (на момент перевода этого учебника, инкрементный поиск на русском языке в XEmacs'е под X11/Xkb не работает. В консоли все ok. Соответственно вы можете проверить, как ведет себя ваша версия Emacs'а при попытке ввода русских букв в инкрементном поиске).

     c bla-bla cu bla-bla curs bla-bla cursor

  >> Итак, вы нашли первое вхождение слова "cursor". Cотрите парочку последних символов в строке поиска (с помощью команды удаления последнего символа, или , в зависимости от терминала). Обратите внимание, как двигается курсор. Чтобы продолжить поиск, нажмите C-s еще раз. Нажмите чтобы выйти из поиска.

  Вы поняли, что происходило? По мере того, как вы набираете строку поиска, Emacs пытается найти ее ближайшее вхождение и для удобства подсвечивает его. Чтобы найти следующее вхождение, нужно нажать C-s еще раз. Если Emacs не может найти строку, в минибуфере будет написано, что текущий поиск неудачен (failing i-search). Отменить поиск не перенося курсор можно с помощью C-g.

  Если в процессе инкрементного поиска вы вводите команду удаления последнего символа, то поиск откатывается на место первого вхождения усеченной строки. Предположим, вы набрали "c" и увидели первое вхождение буквы "c". Теперь, если вы нажмете "u", то курсор передвинется на первое вхождение строки "cu". Если теперь вы удалите символ "u" с помощью команды удаления последнего символа, то курсор вернется обратно на первое вхождение буквы "c".

  Если в процессе инкрементного поиска вы введете control- или meta- символ (за исключением команд, имеющих специальное значение в режиме поиска, таких как C-s и C-r), то поиск будет прерван (именно поэтому могут возникнуть сложности с поиском русских букв, которые, в зависимости от способов русификации, могут интерпретироваться как управляющие символы).

  Итак, C-s ищет строку символов в тексте "ниже" курсора. Чтобы искать в обратном направлении, используйте команду C-r. Все, что мы говорили про C-s, справедливо и для обратного поиска, за исключением того, что направление меняется на противоположное.
  МНОГООКОННОСТЬ

  Одна из полезных возможностей Emacs'а - поддержка многооконности, то есть в одно и тоже время на экране может быть открыто более одного окна.

  >> Подведите курсор к этой строке и нажмите C-u 0 C-l.

  >> Теперь нажмите C-x 2 - экран разделится на два окна. В обоих окнах вы видите этот учебник. Курсор остался в верхнем окне.

  >> Нажмите C-M-v, чтобы пролистать текст в нижнем окне (если на вашей клавиатуре нет ни Meta ни Alt - наберите ECS C-v).

  >> Нажмите C-x o ("o" от англ. other - другой), чтобы переместить курсор в нижнее окно. Используйте C-v и M-v, чтобы пролистывать текст в нижнем окне, продолжая читать эти инструкции в верхнем.

  >> Нажмите C-x o опять, чтобы вернуть курсор в верхнее окно. Курсор вернется в то место, где он был раньше.

  Итак, вы можете использовать C-x o для переключения между окнами. В каждом окне курсор имеет свое собственное положение, но отображается он только в одном. Все стандартные команды редактирования работают именно в том окне, в котором находится курсор. Это окно называется "активным" (selected).

  Команда C-M-v очень полезна, если вы редактируете текст в одном окне, а второе используете для подсказки. Также эта команда незаменима при переводе: в одном окне вы набиваете перевод, а в другом видите исходный текст. С помощью команды C-M-v вы пролистываете текст во втором окне не выходя из первого.

  C-M-v является примером Control-Meta-символа. Если у вас есть клавиша META (ALT), то такая команда вводится путем нажатия v при удерживаемых управляющих клавишах CONTROL и META. Неважно какая из них нажимается первой, так как они работают независимо друг от друга.

  Если клавиши META на вашей клавиатуре нет, вы можете использовать вместо нее ESC, но в этом случае важна последовательность: нужно нажать ECS а потом C-v; CTRL-ESC-v не сработает. Это связано с тем, что ESC является сама по себе символом, а не управляющей клавишей.

  >> Нажмите C-x 1 (в верхнем окне), чтобы закрыть нижнее.

  (Если набрать C-x 1 в нижнем окне, то закроется верхнее, то есть смысл команды следующий: оставить активное окно и закрыть остальные).

  Естественно, никто не заставляет вам отображать один и тот же буфер в обоих окнах. Если вы нажмете C-x C-f и откроете таким образом файл в одном окне, то содержимое второго не изменится. То есть вы можете открывать файлы в разных окнах независимо друг от друга.

  Вот еще один пример как использовать два окна для отображения разных вещей:

  >> Нажмите C-x 4 C-f и введите имя одного из своих файлов. Эта команда открывает файл в нижнем окне и переносит туда курсор.

  >> Нажмите C-x o, чтобы вернуться в верхнее окно и C-x 1, чтобы закрыть нижнее.
  УРОВНИ РЕКУРСИВНОГО РЕДАКТИРОВАНИЯ

  Иногда вы можете оказаться в режиме "уровень рекурсивного редактирования". Вы опознаете его по квадратным скобкам, которые будут стоять по сторонам от обычных в строке состояния. То есть там будет написано [(Fundamental)] вместо (Fundamental).

  Чтобы выйти из такого режима, нажмите ESC ESC ESC. Это команда "убрать", "выйти" на все случаи жизни. Вы можете использовать ее также для того, чтобы закрыть лишние окна или выйти из минибуфера.

  >> Нажмите M-x, чтобы войти в минибуфер, а потом ESC ESC ESC, чтобы выйти из него.

  Команда C-g не поможет вам выйти из уровня рекурсивного редактирования, так как она используется для отмены команд и аргументов ВНУТРИ этого режима.
  КАК ПОЛУЧИТЬ БОЛЬШЕ ИНФОРМАЦИИ

  В этом учебнике мы постарались предоставить вам базу знаний, необходимую для того, чтобы начать работать с Emacs'ом. Emacs обладает настолько большим количеством возможностей, что просто невозможно описать их все здесь. Однако, если вам захочется почитать что-нибудь еще про Emacs, воспользуйтесь командами помощи: они все начинаются с C-h (этот префикс называют "символом справки").

  Чтобы получить справку, нажмите C-h и еще один символ, в зависимости от того, какого рода справку вы хотите получить. Если вы в замешательстве, используйте C-h ? - Emacs покажет вам, какие виды помощи он может предоставить. Если нажали C-h а потом решили, что справка вам не нужна, просто нажмите C-g.

  (На некоторых системах команда C-h бывает переопределена. Это не вполне корректно, так что вы можете пожаловаться системному администратору. Тем не менее, если команда C-h не работает, попробуйте использовать вместо нее M-x help ).

  Простейшая команда помощи - C-h c.

  >> Нажмите "C-h c" и какую-нибудь команду: Emacs выдаст краткое описание этой команды. Например, на C-h c C-p вы увидите что-то вроде "C-p runs the command previous-line" (англ.: C-p выполняет команду "предыдущая-строка").

  То есть "C-h c" показывает вам название функции, которую активизирует заданная команда. Названия функций используются в основном для настройки и расширения возможностей Emacs'а, но так как названия функций непосредственно связаны с тем, что эти функции делают, то команда "C-h c" может послужить простейшей документацией, достаточной как минимум для того, чтобы напомнить вам о работе тех команд, которые вы уже знаете.

  Длинные команды типа C-x 4 C-f также допустимы после C-h c.

  Чтобы получить более развернутую информацию по команде, используйте C-h k вместо C-h c.

  >> Наберите C-h k C-p.

  Таким образом вы посмотрите документацию по команде C-p в отдельном окне. Когда дочитаете, нажмите q, чтобы закрыть его.

  Вот еще парочка полезных справочных команд:

     С-h f	Описание функции.  Требует ввести название функции.

  >> Попробуйте набрать C-h f previous-line. Вы увидите документацию по функции previous-line (англ.: предыдущая строка), которая привязана к команде C-p.

     C-h a	Найти похожие функции.  Введите набор символов и вы
                  увидите все функции и переменные, в названиях которых
                  он присутствует.  Функции, которые могут быть вызваны
                  с помощью M-x будут помечены слева символом "*".

  >> Наберите C-h a newline.

  Появится список всех функций и переменных, в названия которых содержат "newline". Используя команды управления курсором и или кликаясь средней кнопкой на интересующей функции, можно получить ее описание. "q", как всегда, выход из режима справки.
  ЗАКЛЮЧЕНИЕ

  Помните, чтобы выйти из Emacs'а окончательно, используйте C-x C-c. Чтобы временно выйти в командную строку или свернуть окно XEmacs'а под X Window System, пользуйтесь C-z.

  Предполагается, что этот учебник должен быть понятен для всех новых пользователей, так что если вам что-то не ясно, не рвите на себе волосы - жалуйтесь ;)
  УСЛОВИЯ КОПИРОВАНИЯ

  Этот учебник ведет историю от длинной линии учебников по Emacs'у, берущую начало от того, который был написан Стюартом Кракрафтом (Stuart Cracraft) для начальной версии Emacs'а. Бен Винг (Ben Wing) внес дополнения, касающиеся работы под X Window System. Мартин Бачхолц (Martin Buchholz) и Хрвоже Никсик (Hrvoje Niksic) внесли поправки относительно XEmacs'а. Перевод на русский язык сделал Антон Вилькин (vilkin@mail.ru).

  Эта версия учебника, аналогично GNU Emacs'у, защищена законом об авторском праве и предоставляется с разрешением к распространению при соблюдении следующих условий:

  Copyright (c) 1985, 1996 Free Software Foundation

  Permission is granted to anyone to make or distribute verbatim copies of this document as received, in any medium, provided that the copyright notice and permission notice are preserved, and that the distributor grants the recipient permission for further redistribution as permitted by this notice. Permission is granted to distribute modified versions of this document, or of portions of it, under the above conditions, provided also that they carry prominent notices stating who last altered them.

  Условия распространения самого Emacs'а более сложны, но выдержаны в том же духе. Пожалуйста, прочтите файл COPYING и потом свободно раздавайте копии GNU Emacs'а своим друзьям.
  Литература по Unix.



